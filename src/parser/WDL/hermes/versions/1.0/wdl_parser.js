/* eslint-disable */
/*
 * This file was generated by Hermes Parser Generator on Wed Jan 15 18:36:20 2020
 *
 * Hermes command: hermes generate ./grammar.hgr --language=javascript --name=wdl --nodejs --header
 * Run from: . (relative to this file)
 * Hermes version: hermes-parser 2.0rc6
 *
 * !!! DO NOT CHANGE THIS FILE DIRECTLY !!!
 *
 * If you wish to change something in this file, either change the grammar and
 * re-generate this file, or change the templates in Hermes and regenerate.
 * See the Hermes repository: http://github.com/scottfrazer/hermes
 */
if (!String.prototype.format) {
  String.prototype.format = function() {
    var args = arguments;
    return this.replace(/{(\d+)}/g, function(match, number) {
      return typeof args[number] != 'undefined' ? args[number] : match;
    });
  };
}
String.prototype.lstrip = function() {
  return this.replace(/^\s*/g, "");
}
function parse_tree_string(parsetree, indent, b64_source) {
  return _parse_tree_string(parsetree, indent, b64_source, 0);
}
function _parse_tree_string(parsetree, indent, b64_source, indent_level) {
  if (typeof(indent) != 'number' || indent <= 0) {
    indent = undefined
  }
  var indent_str = typeof(indent) !== 'undefined' ? Array(indent * indent_level + 1).join(' ') : ''
  if (parsetree instanceof ParseTree) {
    var children = []
    for (var i in parsetree.children) {
      children.push(_parse_tree_string(parsetree.children[i], indent, b64_source, indent_level + 1))
    }
    if (typeof(indent) == 'undefined' || children.length == 0) {
      return '{0}({1}: {2})'.format(indent_str, parsetree.nonterminal.to_string(), children.join(', '))
    } else {
      return '{0}({1}:\n{2}\n{3})'.format(
        indent_str,
        parsetree.nonterminal.to_string(),
        children.join(',\n'),
        indent_str
      )
    }
  } else if (parsetree instanceof Terminal) {
    return indent_str + parsetree.to_string(b64_source)
  }
}
function ast_string(ast, indent, b64_source) {
  return _ast_string(ast, indent, b64_source, 0);
}
function _ast_string(ast, indent, b64_source, indent_level) {
  if (typeof(indent) != 'number' || indent <= 0) {
    indent = undefined
  }
  var indent_str = typeof(indent) !== 'undefined' ? Array(indent * indent_level + 1).join(' ') : ''
  var next_indent_str = typeof(indent) !== 'undefined' ? Array(indent * (indent_level+1) + 1).join(' ') : ''
  if (ast instanceof Ast) {
    var children = {}
    for (var key in ast.attributes) {
      children[key] = _ast_string(ast.attributes[key], indent, b64_source, indent_level + 1)
    }
    if (typeof(indent) == 'undefined') {
      var strs = []
      for (var key in children) {
        strs.push('{0}={1}'.format(key, children[key]))
      }
      return '({0}: {1})'.format(
        ast.name,
        strs.join(', ')
      )
    } else {
      var strs = []
      for (var key in children) {
        strs.push('{0}{1}={2}'.format(next_indent_str, key, children[key]))
      }
      return '({0}:\n{1}\n{2})'.format(
        ast.name,
        strs.join(',\n'),
        indent_str
      )
    }
  } else if (ast instanceof AstList) {
    var children = []
    for (var key in ast.list) {
      children.push(_ast_string(ast.list[key], indent, b64_source, indent_level + 1))
    }
    if (typeof(indent) == 'undefined' || children.length == 0) {
      return '[{0}]'.format(children.join(', '))
    } else {
      var strs = []
      for (var index in children) {
        strs.push('{0}{1}'.format(next_indent_str, children[index]))
      }
      return '[\n{0}\n{1}]'.format(
        strs.join(',\n'),
        indent_str
      )
    }
  } else if (ast instanceof Terminal) {
    return ast.to_string(b64_source)
  } else {
    return (ast == null) ? 'None' : ast.to_string()
  }
}
function Terminal(id, str, source_string, resource, line, col) {
  this.id = id;
  this.str = str;
  this.source_string = source_string;
  this.resource = resource;
  this.line = line;
  this.col = col;
  this.to_ast = function() {
    return this;
  };
  this.to_string = function(b64_source) {
    return '<{0}:{1}:{2} {3} "{4}">'.format(
      this.resource,
      this.line,
      this.col,
      this.str,
      b64_source ? Base64.encode(this.source_string) : this.source_string
    )
  };
}
function NonTerminal(id, str) {
  this.id = id;
  this.str = str;
  this.to_string = function() {
    return this.str;
  };
}
function AstTransformSubstitution(idx) {
  this.idx = idx;
  this.to_string = function() {
    return '$' + this.idx;
  };
}
function AstTransformNodeCreator(name, parameters) {
  this.name = name;
  this.parameters = parameters;
  this.to_string = function() {
    var arr = [];
    for (key in this.parameters) {
      arr.push('{0}=${1}'.format(key, this.parameters[key]));
    }
    return '{0} ( {1} )'.format(this.name, arr.join(', '));
  };
}
function AstList(list) {
  this.list = list
  this.push = function(element) {
    this.list.push(element);
  };
  this.to_ast = function() {
    var arr = [];
    for (item in this.list) {
      arr.push(item.to_ast());
    }
    return arr;
  };
}
function ParseTree(nonterminal) {
  this.children = [];
  this.nonterminal = nonterminal;
  this.astTransform = null;
  this.isExpr = false;
  this.isNud = false;
  this.isPrefix = false;
  this.isInfix = false;
  this.nudMorphemeCount = 0;
  this.isExprNud = false;
  this.listSeparator = null;
  this.list = false;
  this.add = function(tree) {
    this.children.push(tree);
  }
  this.to_ast = function() {
    var name;
    if (this.list == true) {
      if (this.children.length == 0) {
        return new AstList([]);
      }
      var end = this.children.length - 1;
      var list = [];
      for (var i = 0; i < this.children.length; i++) {
        if (this.children[i] instanceof Terminal && this.children[i].id == this.listSeparator)
          continue;
        list.push(this.children[i].to_ast());
      }
      return new AstList(list);
    } else if (this.isExpr == true) {
      if (this.astTransform instanceof AstTransformSubstitution) {
        return this.children[this.astTransform.idx].to_ast();
      } else if (this.astTransform instanceof AstTransformNodeCreator) {
        var parameters = {}
        for (name in this.astTransform.parameters) {
          var idx = this.astTransform.parameters[name];
          var child = null;
          if (idx == '$') {
            child = this.children[0];
          } else if (this.children[0] instanceof ParseTree && this.children[0].isNud && !this.children[0].isPrefix && !this.isExprNud && !this.isInfix) {
            if (idx < this.children[0].nudMorphemeCount) {
              child = this.children[0].children[idx]
            } else {
              var index = idx - this.children[0].nudMorphemeCount + 1
              child = this.children[index]
            }
          } else if (this.children.length == 1 && !(this.children[0] instanceof ParseTree) && !(this.children[0] instanceof Array)) {
            return this.children[0];
          } else {
            child = this.children[idx];
          }
          parameters[name] = child.to_ast()
        }
        return new Ast(this.astTransform.name, parameters);
      }
    } else {
      if (this.astTransform instanceof AstTransformSubstitution) {
        return this.children[this.astTransform.idx].to_ast()
      } else if (this.astTransform instanceof AstTransformNodeCreator) {
        var parameters = {};
        for (name in this.astTransform.parameters) {
          parameters[name] = this.children[this.astTransform.parameters[name]].to_ast();
        }
        return new Ast(this.astTransform.name, parameters);
        return x;
      } else if (this.children.length) {
        return this.children[0].to_ast();
      } else {
        return null;
      }
    }
  }
  this.to_string = function() {
    var children = []
    for (i in this.children) {
      var child = this.children[i];
      if (child instanceof Array) {
        var stringify = child.map(function(x) {return x.to_string()});
        children.push('[' + stringify.join(', ') + ']');
      } else {
        children.push(child.to_string());
      }
    }
    return '(' + this.nonterminal.to_string() + ': ' + children.join(', ') + ')'
  }
}
function Ast(name, attributes) {
  this.name = name;
  this.attributes = attributes;
  this.to_string = function() {
    var arr = [];
    for (var key in this.attributes) {
      var value = this.attributes[key];
      if (value instanceof Array) {
        var stringify = value.map(function(x) {return x.to_string()});
        value = '[{0}]'.format(stringify.join(', '));
      } else {
        value = value.to_string();
      }
      arr.push('{0}={1}'.format(key.to_string(), value))
    }
    return '({0}: {1})'.format(this.name, arr.join(', '));
  }
}
function SyntaxError(message) {
  this.name = 'SyntaxError';
  this.message = message;
  this.to_string = function() {
    return this.message;
  }
}
function TokenStream(list) {
  this.list = list;
  this.index = 0;
  this.advance = function() {
    this.index += 1;
    return this.current();
  }
  this.last = function() {
    return this.list[this.list.length - 1];
  }
  this.current = function() {
    if (this.index < this.list.length) {
      return this.list[this.index];
    } else {
      return null;
    }
  }
}
function DefaultSyntaxErrorFormatter() {
  this.unexpected_eof = function(nonterminal, expected_terminals, nonterminal_rules) {
    return "Error: unexpected end of file";
  }
  this.excess_tokens = function(nonterminal, terminal) {
    return "Finished parsing without consuming all tokens.";
  }
  this.unexpected_symbol = function(nonterminal, actual_terminal, expected_terminals, rule) {
    return "Unexpected symbol (line {0}, col {1}) when parsing parse_{2}.  Expected {3}, got {4}.".format(
      actual_terminal.line,
      actual_terminal.col,
      nonterminal,
      expected_terminals.join(', '),
      actual_terminal.to_string(true)
    );
  }
  this.no_more_tokens = function(nonterminal, expected_terminal, last_terminal) {
    return "No more tokens.  Expecting " + expected_terminal;
  }
  this.invalid_terminal = function(nonterminal, invalid_terminal) {
    return "Invalid symbol ID: {0} ({1})".format(invalid_terminal.id, invalid_terminal.string);
  }
  this.missing_list_items = function(method, required, found, last) {
    return "List for "+method+" requires "+required+" items but only "+found+" were found.";
  }
  this.missing_terminator = function(method, terminator, last) {
    return "List for "+method+" is missing a terminator";
  }
}
function ParserContext(tokens, error_formatter) {
  this.tokens = tokens;
  this.error_formatter = error_formatter;
  this.nonterminal_string = null;
  this.rule_string = null;
}
function MultiRegExp(par) {
  var regex;
  if (par.source !== undefined){
    regex = par;
  } else {
    var exp = par;
    var opts = "";
    if (par.substring(0, 1) == "/") {
      var l = par.lastIndexOf("/");
      opts = par.substring(l + 1, par.length);
      exp = par.substring(1, l);
    }
    regex = new RegExp(exp, opts);
  }
  var expandSource = function (braces, indexer) {
    ret = '';
    for (var i = 0; i < braces.length; i++) {
      if (braces[i].type == 'raw') {
        ret += '(' + braces[i].text + ')';
        indexer.next();
      } else if (braces[i].type == 'brace' && braces[i].containsCapture) {
        ret += braces[i].pre + expandSource(braces[i].children, indexer) + braces[i].post;
      } else if (braces[i].type == 'brace' && !braces[i].isCapture) {
        ret += '(' + braces[i].text.substring(braces[i].pre.length, braces[i].text.length - braces[i].post.length) + ')';
        indexer.next();
      } else if (braces[i].type == 'brace') {
        ret += braces[i].text;
        indexer.next(true);
      } else {
        ret += braces[i].text;
      }
    }
    return ret;
  }
  var captureScan = function(braces, parent) {
    var containsCapture = false;
    for (var i = 0; i < braces.length; i++) {
      captureScan(braces[i].children, braces[i]);
      braces[i].isCapture = braces[i].text.indexOf('(?:') != 0;
      if (braces[i].isCapture) {
        containsCapture = true;
      }
      if (braces[i].isCapture && braces[i].containsCapture) {
        throw "nested captures not permitted, use (?:...) where capture is not intended";
      }
    }
    if (parent) {
      parent.containsCapture = containsCapture;
    }
  }
  var fillGaps = function(braces, text) {
    var pre = /^\((\?.)?/.exec(text);
    pre = pre == null ? '' : pre[0];
    var post = /\)$/.exec(text);
    post = post == null ? '' : post[0];
    var i = 0;
    if (braces.length > 0) {
      fillGaps(braces[0].children, braces[0].text);
    }
    if (braces.length > 0 && braces[0].pos > pre.length) {
      braces.splice(0, 0, {
        type: 'raw',
        pos: pre.length,
        length: braces[0].pos,
        text: text.substring(pre.length, braces[0].pos)
      });
      i++;
    }
    for (i++; i < braces.length; i++) {
      fillGaps(braces[i].children, braces[i].text);
      if (braces[i].pos > braces[i - 1].pos + braces[i - 1].length) {
        braces.splice(i, 0, {
          type: 'raw', pos: braces[i - 1].pos + braces[i - 1].length,
          length: braces[i].pos - (braces[i - 1].pos + braces[i - 1].length),
          text: text.substring(braces[i - 1].pos + braces[i - 1].length,
            braces[i].pos)
        });
        i++;
      }
    }
    if (braces.length == 0) {
      braces.push({
        type: 'raw',
        pos: pre.length,
        length: text.length - post.length - pre.length,
        text: text.substring(pre.length, text.length - post.length)
      });
    } else if (braces[braces.length - 1].pos + braces[braces.length - 1].length < text.length - post.length) {
      var pos = braces[braces.length - 1].pos + braces[braces.length - 1].length;
      var txt = text.substring(pos, text.length - post.length);
      braces.push({type: 'raw', pos: pos, length: txt.length, text: txt});
    }
  }
  var GetBraces = function(text) {
    var ret = [];
    var shift = 0;
    do {
      var brace = GetBrace(text);
      if (brace == null) {
        break;
      } else {
        text = text.substring(brace.pos + brace.length);
        var del = brace.pos + brace.length;
        brace.pos += shift;
        shift += del;
        ret.push(brace);
      }
    } while (brace != null);
    return ret;
  }
  var GetBrace = function(text) {
    var ret = {pos: -1, length: 0, text: '', children: [], type: 'brace'};
    var openExp = /^(?:\\.|[^\)\\\(])*\(\?./;
    var pre = 3;
    var post = 1;
    var m = openExp.exec(text);
    if (m == null) {
      m = /^(?:\\.|[^\)\\\(])*\(/.exec(text);
      pre = 1;
    }
    if (m != null) {
      ret.pos = m[0].length - pre;
      ret.children = GetBraces(text.substring(m[0].length));
      for (var i = 0; i < ret.children.length; i++) {
        ret.children[i].pos += pre;
      }
      var closeExp = /^(?:\\.|[^\\\(\)])*\)/;
      var closeExpAlt = /^(?:\\.|[^\\\(\)])*\)\?/;
      var from = ret.children.length <= 0 ? ret.pos + pre :
        ret.children[ret.children.length - 1].pos +
        ret.children[ret.children.length - 1].length +
        m[0].length - pre;
      var m2 = closeExp.exec(text.substring(from));
      var m3 = closeExpAlt.exec(text.substring(from));
      if (m3 !== null && m3.length - 1 <= m2.length) {
        m2 = m3;
        post = 2;
      }
      if (m2 == null) {
        return null;
      } else {
        ret.length = m2[0].length + from - ret.pos;
        ret.text = text.substring(ret.pos, ret.pos + ret.length);
      }
    }
    if (ret.text == '()' || /^\(\?.\)$/.test(ret.text)) {
      throw 'empty braces not permitted';
    }
    if (ret.pos != -1) {
      ret.pre = ret.text.substring(0, pre);
      ret.post = ret.text.substring(ret.text.length - post, ret.text.length);
    }
    return ret.pos == -1 ? null : ret;
  }
  var fixOrs = function(braces_W_raw) {
    var orFind = /^(\\.|[^\\|])*\|/;
    for (var i = 0; i < braces_W_raw.length; i++) {
      if (braces_W_raw[i].type == 'raw') {
        var fullText = braces_W_raw[i].text;
        var m = orFind.exec(fullText);
        if (m != null) {
          var or = {type: 'or', pos: m[0].length - 1 + braces_W_raw[i].pos, length: 1, text: '|'};
          var raw = {
            type: 'raw', pos: m[0].length + braces_W_raw[i].pos,
            length: fullText.length - m[0].length,
            text: fullText.substring(m[0].length, fullText.length)
          };
          braces_W_raw[i].text = fullText.substring(0, m[0].length - 1);
          braces_W_raw[i].length = braces_W_raw[i].text.length;
          braces_W_raw.splice(i + 1, 0, or, raw);
          i += 1;
        }
      } else if (braces_W_raw[i].type == 'brace') {
        fixOrs(braces_W_raw[i].children, braces_W_raw[i].text);
      }
    }
  }
  var source = regex.source;
  var braces = GetBraces(source);
  captureScan(braces);
  fillGaps(braces, source);
  fixOrs(braces);
  var indexer = {
    i: 1, next:
      function(realPoint) {
        if (realPoint) {
          this.points.push(this.i);
        }
        return this.i++;
      }, points: []
  };
  source = expandSource(braces, indexer);
  this.dataPoints = indexer.points;
  var options = (regex.ignoreCase ? "i" : "") + (regex.global ? "g" : "") + (regex.multiline ? "m" : "");
  this.regex = new RegExp(source, options);
  this.exec = function(text) {
    var m = this.regex.exec(text);
    if (m == null) {
      return {};
    }
    var ret = {};
    var ch = 0;
    for (var i = 1; i < m.length; i++) {
      if (m[i] !== null && m[i] !== undefined) {
        var pos = this.dataPoints.indexOf(i);
        if (pos != -1) {
          ret[pos] = {index: ch, text: m[i]};
        }
        ch += m[i].length;
      }
    }
    for (var i = 0; i < this.dataPoints.length; i++) {
      if (ret[i] === undefined) {
        ret[i] = null;
      }
    }
    return ret;
  }
}
var Base64 = {
  // private property
  _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  // public method for encoding
  encode: function(input) {
    var output = "";
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0;
    input = Base64._utf8_encode(input);
    while (i < input.length) {
      chr1 = input.charCodeAt(i++);
      chr2 = input.charCodeAt(i++);
      chr3 = input.charCodeAt(i++);
      enc1 = chr1 >> 2;
      enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
      enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
      enc4 = chr3 & 63;
      if (isNaN(chr2)) {
        enc3 = enc4 = 64;
      } else if (isNaN(chr3)) {
        enc4 = 64;
      }
      output = output +
        Base64._keyStr.charAt(enc1) + Base64._keyStr.charAt(enc2) +
        Base64._keyStr.charAt(enc3) + Base64._keyStr.charAt(enc4);
    }
    return output;
  },
  // public method for decoding
  decode: function(input) {
    var output = "";
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    while (i < input.length) {
      enc1 = Base64._keyStr.indexOf(input.charAt(i++));
      enc2 = Base64._keyStr.indexOf(input.charAt(i++));
      enc3 = Base64._keyStr.indexOf(input.charAt(i++));
      enc4 = Base64._keyStr.indexOf(input.charAt(i++));
      chr1 = (enc1 << 2) | (enc2 >> 4);
      chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
      chr3 = ((enc3 & 3) << 6) | enc4;
      output = output + String.fromCharCode(chr1);
      if (enc3 != 64) {
        output = output + String.fromCharCode(chr2);
      }
      if (enc4 != 64) {
        output = output + String.fromCharCode(chr3);
      }
    }
    output = Base64._utf8_decode(output);
    return output;
  },
  // private method for UTF-8 encoding
  _utf8_encode: function(string) {
    string = string.replace(/\r\n/g, "\n");
    var utftext = "";
    for (var n = 0; n < string.length; n++) {
      var c = string.charCodeAt(n);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if ((c > 127) && (c < 2048)) {
        utftext += String.fromCharCode((c >> 6) | 192);
        utftext += String.fromCharCode((c & 63) | 128);
      } else {
        utftext += String.fromCharCode((c >> 12) | 224);
        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
        utftext += String.fromCharCode((c & 63) | 128);
      }
    }
    return utftext;
  },
  // private method for UTF-8 decoding
  _utf8_decode: function(utftext) {
    var string = "";
    var i = 0;
    var c = c1 = c2 = 0;
    while (i < utftext.length) {
      c = utftext.charCodeAt(i);
      if (c < 128) {
        string += String.fromCharCode(c);
        i++;
      } else if ((c > 191) && (c < 224)) {
        c2 = utftext.charCodeAt(i + 1);
        string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
        i += 2;
      } else {
        c2 = utftext.charCodeAt(i + 1);
        c3 = utftext.charCodeAt(i + 2);
        string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
        i += 3;
      }
    }
    return string;
  }
}
// Section: Parser
var terminals = {
  0: 'cmd_part',
  1: 'rparen',
  2: 'lt',
  3: 'boolean',
  4: 'meta',
  5: 'struct',
  6: 'raw_cmd_end',
  7: 'raw_cmd_start',
  8: 'expression_placeholder_start',
  9: 'dot',
  10: 'e',
  11: 'output',
  12: 'not',
  13: 'dash',
  14: 'double_equal',
  15: 'integer',
  16: 'fqn',
  17: 'else',
  18: 'in',
  19: 'meta_value',
  20: 'not_equal',
  21: 'quote',
  22: 'parameter_meta',
  23: 'version_name',
  24: 'plus',
  25: 'lteq',
  26: 'gt',
  27: 'colon',
  28: 'comma',
  29: 'raw_command',
  30: 'import',
  31: 'call',
  32: 'asterisk',
  33: 'float',
  34: 'lbrace',
  35: 'scatter',
  36: 'workflow',
  37: 'identifier',
  38: 'qmark',
  39: 'percent',
  40: 'task',
  41: 'lsquare',
  42: 'input',
  43: 'double_pipe',
  44: 'slash',
  45: 'version',
  46: 'equal',
  47: 'string',
  48: 'if',
  49: 'runtime',
  50: 'while',
  51: 'lparen',
  52: 'null',
  53: 'gteq',
  54: 'object',
  55: 'expression_placeholder_end',
  56: 'then',
  57: 'type',
  58: 'rsquare',
  59: 'as',
  60: 'cmd_attr_hint',
  61: 'type_e',
  62: 'rbrace',
  63: 'alias',
  64: 'double_ampersand',
  'cmd_part': 0,
  'rparen': 1,
  'lt': 2,
  'boolean': 3,
  'meta': 4,
  'struct': 5,
  'raw_cmd_end': 6,
  'raw_cmd_start': 7,
  'expression_placeholder_start': 8,
  'dot': 9,
  'e': 10,
  'output': 11,
  'not': 12,
  'dash': 13,
  'double_equal': 14,
  'integer': 15,
  'fqn': 16,
  'else': 17,
  'in': 18,
  'meta_value': 19,
  'not_equal': 20,
  'quote': 21,
  'parameter_meta': 22,
  'version_name': 23,
  'plus': 24,
  'lteq': 25,
  'gt': 26,
  'colon': 27,
  'comma': 28,
  'raw_command': 29,
  'import': 30,
  'call': 31,
  'asterisk': 32,
  'float': 33,
  'lbrace': 34,
  'scatter': 35,
  'workflow': 36,
  'identifier': 37,
  'qmark': 38,
  'percent': 39,
  'task': 40,
  'lsquare': 41,
  'input': 42,
  'double_pipe': 43,
  'slash': 44,
  'version': 45,
  'equal': 46,
  'string': 47,
  'if': 48,
  'runtime': 49,
  'while': 50,
  'lparen': 51,
  'null': 52,
  'gteq': 53,
  'object': 54,
  'expression_placeholder_end': 55,
  'then': 56,
  'type': 57,
  'rsquare': 58,
  'as': 59,
  'cmd_attr_hint': 60,
  'type_e': 61,
  'rbrace': 62,
  'alias': 63,
  'double_ampersand': 64,
}
// table[nonterminal][terminal] = rule
var table = [
  [-1, -1, -1, -1, 73, -1, -1, -1, -1, -1, -1, 73, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 73, -1, -1, -1, -1, -1, -1, -1, -1, 73, -1, -1, 72, 73, -1, 73, -1, -1, -1, -1, 73, -1, -1, -1, -1, -1, 73, -1, 73, -1, -1, -1, -1, -1, -1, 73, -1, -1, -1, 73, 73, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 54, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, 18, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, -1, -1, 18, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 41, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [34, -1, -1, -1, -1, -1, -1, -1, 35, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, -1, -1, -1, 52, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, 9, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, 58, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 79, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 22, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 86, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 60, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, 30, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 29, -1, -1, -1, -1, -1, -1, 25, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, 28, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1, -1, 31, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 46, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, 55, -1, -1, -1, -1, -1, -1, 55, -1, 55, 55, -1, 55, -1, -1, -1, -1, -1, 55, -1, -1, 55, -1, -1, -1, -1, -1, -1, -1, -1, 55, 55, -1, -1, 55, -1, -1, -1, 55, -1, -1, -1, -1, -1, -1, 55, -1, -1, 55, -1, -1, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 51, -1, -1, -1, -1, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 51, -1, -1, -1, 51, 51, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, -1, -1],
  [-1, -1, -1, -1, 82, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 77, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, 67, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 68, -1, -1, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, 65, -1, 62, -1, -1, -1, -1, 66, -1, -1, -1, -1, -1, 64, -1, 63, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 62, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 80, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, 71, -1, -1, -1, -1, -1, -1, 71, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 71, -1, -1, -1, -1, -1, -1, -1, -1, 71, -1, -1, 71, 71, -1, 71, -1, -1, -1, -1, 71, -1, -1, -1, -1, -1, 71, -1, 71, -1, -1, -1, -1, -1, -1, 71, -1, 70, -1, 71, 71, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 85, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 43, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 38, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 44, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 87, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 83, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, -1, 53, -1, -1, -1],
  [-1, -1, -1, -1, 45, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
]
var nonterminal_first = {
  65: [34, -1],
  66: [61, 57, -1, 37],
  67: [46],
  68: [15, 33, 34, 3, 19, 41, 21, 52],
  69: [59],
  70: [45],
  71: [8, -1, 47],
  72: [-1, 59],
  73: [42],
  74: [49],
  75: [0, 8],
  76: [57, 61, 37],
  77: [63, -1],
  78: [57, 61, 37],
  79: [8],
  80: [57, 61, 37],
  81: [21],
  82: [21],
  83: [57, 61, 37],
  84: [11],
  85: [61, 57, -1, 37],
  86: [4, 35, 37, 42, 11, 48, 50, 57, 22, 61, -1, 31],
  87: [42],
  88: [-1, 37],
  89: [30],
  90: [33, 34, 3, 37, 41, 10, 48, 13, 54, 15, 51, 21, 24, -1, 12],
  91: [63],
  92: [37],
  93: [-1, 37],
  94: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  95: [29],
  96: [36],
  97: [8, 47],
  98: [4, 57, 37, 22, 61, 42, 11, 29, 49],
  99: [22],
  100: [34],
  101: [15, 34, 51, 33, 3, 21, 37, 13, 24, 10, 41, 48, 12, 54],
  102: [61, 57, -1, 37],
  103: [46, -1],
  104: [-1, 42],
  105: [4],
  106: [-1, 47],
  107: [61, 57, -1, 37],
  108: [-1, 30],
  109: [22],
  110: [45],
  111: [33, 34, 3, 37, 41, 10, 13, 48, 54, 15, 51, 21, 24, -1, 12],
  112: [34],
  113: [50, 4, 35, 57, 37, 22, 61, 42, 11, 31, 48],
  114: [-1, 37],
  115: [36, -1, 40, 5],
  116: [4, 57, 37, 22, 61, 42, 11, -1, 29, 49],
  117: [-1, 37],
  118: [59],
  119: [-1, 59],
  120: [35],
  121: [5],
  122: [37],
  123: [34],
  124: [60],
  125: [37],
  126: [37],
  127: [0, 8, -1],
  128: [50],
  129: [-1, 37],
  130: [48],
  131: [36, 5, 40],
  132: [31],
  133: [60, -1],
  134: [57, 61, 37],
  135: [4],
  136: [40],
  137: [33, 34, 3, 41, 52, 15, 19, 21, -1],
}
var nonterminal_follow = {
  65: [4, 35, 37, 42, 11, 48, 50, 57, 22, 61, 62, 31],
  66: [62],
  67: [4, 35, 37, 31, 42, 11, 48, 49, 50, 57, 22, 61, 62, 29],
  68: [62, 28, 58, 37],
  69: [36, 5, -1, 40, 63, 30],
  70: [-1],
  71: [21],
  72: [40, 63, 36, 5, 30, -1],
  73: [4, 35, 37, 31, 42, 11, 48, 49, 50, 57, 22, 61, 62, 29],
  74: [4, 37, 42, 11, 49, 57, 22, 61, 62, 29],
  75: [0, 8, 6],
  76: [28, 58, 37],
  77: [40, 36, 5, 30, -1],
  78: [61, 62, 57, 37],
  79: [0, 8, 47, 6, 21],
  80: [61, 62, 57, 37],
  81: [36, 5, 58, 59, 37, -1, 40, 62, 28, 30],
  82: [10, 11, 14, 25, 27, 32, 33, 34, 35, 37, 39, 44, 53, 48, 50, 56, 58, 61, 62, 12, 1, 2, 3, 4, 9, 13, 17, 15, 20, 21, 22, 24, 26, 28, 29, 31, 41, 42, 43, 49, 54, 51, 55, 57, 60, 64],
  83: [61, 62, 57, 37],
  84: [4, 35, 37, 31, 42, 11, 48, 49, 50, 57, 22, 61, 62, 29],
  85: [62],
  86: [62],
  87: [62],
  88: [62],
  89: [40, 36, 5, 30, -1],
  90: [62],
  91: [36, 5, -1, 40, 63, 30],
  92: [28, 62],
  93: [62],
  94: [1, 2, 3, 4, 9, 10, 11, 12, 13, 14, 17, 15, 20, 21, 22, 24, 25, 26, 27, 28, 32, 29, 31, 33, 34, 35, 37, 39, 41, 42, 43, 44, 53, 48, 49, 54, 51, 50, 55, 56, 57, 58, 60, 61, 62, 64],
  95: [4, 37, 42, 11, 49, 57, 22, 61, 62, 29],
  96: [40, 36, 5, -1],
  97: [8, 47, 21],
  98: [4, 37, 42, 11, 49, 57, 22, 61, 62, 29],
  99: [4, 37, 42, 11, 49, 57, 22, 61, 62, 29],
  100: [4, 35, 37, 31, 42, 11, 48, 49, 50, 57, 22, 61, 62, 29],
  101: [28, 62],
  102: [58],
  103: [61, 62, 57, 37],
  104: [62],
  105: [4, 35, 37, 42, 11, 48, 50, 57, 22, 61, 62, 31],
  106: [21],
  107: [62],
  108: [36, 5, 40, -1],
  109: [4, 35, 37, 42, 11, 48, 50, 57, 22, 61, 62, 31],
  110: [30, -1],
  111: [1, 58],
  112: [4, 35, 37, 42, 11, 48, 50, 57, 22, 61, 62, 31],
  113: [4, 35, 37, 42, 11, 48, 50, 57, 22, 61, 62, 31],
  114: [62],
  115: [-1],
  116: [62],
  117: [62],
  118: [34, 4, 35, 37, 42, 11, 48, 50, 57, 22, 61, 62, 31],
  119: [34, 4, 35, 37, 42, 11, 48, 50, 57, 22, 61, 62, 31],
  120: [4, 35, 37, 42, 11, 48, 50, 57, 22, 61, 62, 31],
  121: [40, 36, 5, -1],
  122: [28, 62, 37],
  123: [4, 37, 42, 11, 49, 57, 22, 61, 62, 29],
  124: [33, 34, 3, 37, 41, 10, 13, 48, 54, 15, 51, 21, 60, 24, 12],
  125: [62, 37],
  126: [28, 62],
  127: [6],
  128: [4, 35, 37, 42, 11, 48, 50, 57, 22, 61, 62, 31],
  129: [62],
  130: [4, 35, 37, 42, 11, 48, 50, 57, 22, 61, 62, 31],
  131: [40, 36, 5, -1],
  132: [4, 35, 37, 42, 11, 48, 50, 57, 22, 61, 62, 31],
  133: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  134: [4, 35, 37, 31, 42, 11, 48, 49, 50, 57, 22, 61, 62, 29],
  135: [4, 37, 42, 11, 49, 57, 22, 61, 62, 29],
  136: [40, 36, 5, -1],
  137: [58],
}
var rule_first = {
  0: [-1, 30],
  1: [-1, 36, 5, 40],
  2: [45],
  3: [36],
  4: [40],
  5: [5],
  6: [45],
  7: [-1, 57, 61, 37],
  8: [5],
  9: [57, 61, 37],
  10: [47],
  11: [-1],
  12: [21],
  13: [8, -1, 47],
  14: [21],
  15: [47],
  16: [8],
  17: [59],
  18: [-1],
  19: [63, -1],
  20: [30],
  21: [59],
  22: [63],
  23: [4, 57, 37, 22, 61, 42, 11, -1, 29, 49],
  24: [40],
  25: [29],
  26: [42],
  27: [11],
  28: [49],
  29: [22],
  30: [4],
  31: [57, 61, 37],
  32: [0, 8, -1],
  33: [29],
  34: [0],
  35: [8],
  36: [60, -1],
  37: [8],
  38: [60],
  39: [-1, 57, 61, 37],
  40: [42],
  41: [49],
  42: [-1, 37],
  43: [34],
  44: [37],
  45: [4],
  46: [22],
  47: [-1, 37],
  48: [34],
  49: [37],
  50: [46],
  51: [-1],
  52: [57, 61, 37],
  53: [57, 61, 37],
  54: [46],
  55: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  56: [-1, 57, 61, 37],
  57: [11],
  58: [57, 61, 37],
  59: [50, 4, 35, 57, 37, 22, 61, 42, 11, -1, 31, 48],
  60: [36],
  61: [31],
  62: [57, 61, 37],
  63: [50],
  64: [48],
  65: [35],
  66: [42],
  67: [11],
  68: [22],
  69: [4],
  70: [59],
  71: [-1],
  72: [34],
  73: [-1],
  74: [31],
  75: [42],
  76: [-1],
  77: [34],
  78: [-1, 37],
  79: [42],
  80: [59],
  81: [22],
  82: [4],
  83: [50],
  84: [48],
  85: [35],
  86: [37],
  87: [37],
  88: [21],
  89: [3],
  90: [15],
  91: [33],
  92: [52],
  93: [15, 33, 34, 3, 19, 21, 41, -1, 52],
  94: [41],
  95: [-1, 37],
  96: [34],
  97: [-1, 57, 61, 37],
  98: [57],
  99: [57],
  100: [57],
  101: [57],
  102: [37],
  103: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  104: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  105: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  106: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  107: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  108: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  109: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  110: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  111: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  112: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  113: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  114: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  115: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  116: [12],
  117: [24],
  118: [13],
  119: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, -1, 13, 12, 54],
  120: [37],
  121: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  122: [15, 34, 51, 33, 3, 48, 21, 37, 24, 10, 41, 13, 12, 54],
  123: [-1, 37],
  124: [54],
  125: [41],
  126: [15, 34, 51, 33, 3, 21, 37, 13, 24, 10, 41, -1, 48, 12, 54],
  127: [34],
  128: [51],
  129: [48],
  130: [21],
  131: [37],
  132: [3],
  133: [15],
  134: [33],
}
var nonterminal_rules = {
  65: [
    "$_gen17 = $call_brace_block",
    "$_gen17 = :_empty",
  ],
  66: [
    "$_gen10 = list($input_declaration)",
  ],
  67: [
    "$setter = :equal $e -> $1",
  ],
  68: [
    "$meta_value = $static_string",
    "$meta_value = :boolean",
    "$meta_value = :integer",
    "$meta_value = :float",
    "$meta_value = :null",
    "$meta_value = :lsquare $_gen20 :rsquare -> MetaArray( values=$1 )",
    "$meta_value = :lbrace $_gen21 :rbrace -> MetaObject( map=$1 )",
  ],
  69: [
    "$import_namespace = :as :identifier -> $1",
  ],
  70: [
    "$document = $version $_gen0 $_gen1 -> Draft3File( version=$0, imports=$1, body=$2 )",
  ],
  71: [
    "$_gen4 = list($string_piece)",
  ],
  72: [
    "$_gen5 = $import_namespace",
    "$_gen5 = :_empty",
  ],
  73: [
    "$inputs = :input :lbrace $_gen10 :rbrace -> Inputs( inputs=$2 )",
  ],
  74: [
    "$runtime = :runtime $rt_map -> Runtime( map=$1 )",
  ],
  75: [
    "$command_part = :cmd_part",
    "$command_part = $expression_placeholder",
  ],
  76: [
    "$type_e = :type <=> :lsquare $_gen22 :rsquare -> Type( name=$0, subtype=$2 )",
    "$type_e = :type <=> :qmark -> OptionalType( innerType=$0 )",
    "$type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )",
    "$type_e = :type",
    "$type_e = :identifier",
  ],
  77: [
    "$_gen6 = list($import_alias)",
  ],
  78: [
    "$input_declaration = $type_e :identifier $_gen13 -> InputDeclaration( type=$0, name=$1, expression=$2 )",
  ],
  79: [
    "$expression_placeholder = :expression_placeholder_start $_gen9 $e :expression_placeholder_end -> ExpressionPlaceholder( attributes=$1, expr=$2 )",
  ],
  80: [
    "$struct_declaration = $type_e :identifier -> StructEntry( type=$0, name=$1 )",
  ],
  81: [
    "$static_string = :quote $_gen3 :quote -> StaticString( value=$1 )",
  ],
  82: [
    "$string_literal = :quote $_gen4 :quote -> StringLiteral( pieces=$1 )",
  ],
  83: [
    "$output_kv = $type_e :identifier :equal $e -> Output( type=$0, name=$1, expression=$3 )",
  ],
  84: [
    "$outputs = :output :lbrace $_gen14 :rbrace -> Outputs( outputs=$2 )",
  ],
  85: [
    "$_gen14 = list($output_kv)",
  ],
  86: [
    "$_gen15 = list($wf_body_element)",
  ],
  87: [
    "$call_body = :input :colon $_gen19 -> CallBody( inputs=$2 )",
  ],
  88: [
    "$_gen24 = list($object_kv, :comma)",
  ],
  89: [
    "$import = :import $static_string $_gen5 $_gen6 -> Import( uri=$1, namespace=$2, aliases=$3 )",
  ],
  90: [
    "$_gen25 = list($map_kv, :comma)",
  ],
  91: [
    "$import_alias = :alias :identifier :as :identifier -> ImportAlias( old_name=$1, new_name=$3 )",
  ],
  92: [
    "$object_kv = :identifier :colon $e -> ObjectKV( key=$0, value=$2 )",
  ],
  93: [
    "$_gen21 = list($meta_kv, :comma)",
  ],
  94: [
    "$e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )",
    "$e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )",
    "$e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )",
    "$e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )",
    "$e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )",
    "$e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )",
    "$e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )",
    "$e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )",
    "$e = $e :plus $e -> Add( lhs=$0, rhs=$2 )",
    "$e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )",
    "$e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )",
    "$e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )",
    "$e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )",
    "$e = :not $e -> LogicalNot( expression=$1 )",
    "$e = :plus $e -> UnaryPlus( expression=$1 )",
    "$e = :dash $e -> UnaryNegation( expression=$1 )",
    "$e = :identifier <=> :lparen $_gen23 :rparen -> FunctionCall( name=$0, params=$2 )",
    "$e = $e <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )",
    "$e = $e <=> :dot :identifier -> MemberAccess( value=$0, member=$2 )",
    "$e = :object :lbrace $_gen24 :rbrace -> ObjectLiteral( map=$2 )",
    "$e = :lsquare $_gen23 :rsquare -> ArrayLiteral( values=$1 )",
    "$e = :lbrace $_gen25 :rbrace -> MapLiteral( map=$1 )",
    "$e = :lparen $_gen23 :rparen -> TupleLiteral( values=$1 )",
    "$e = :if $e :then $e :else $e -> TernaryIf( cond=$1, iftrue=$3, iffalse=$5 )",
    "$e = $string_literal",
    "$e = :identifier",
    "$e = :boolean",
    "$e = :integer",
    "$e = :float",
  ],
  95: [
    "$command = :raw_command :raw_cmd_start $_gen8 :raw_cmd_end -> RawCommand( parts=$2 )",
  ],
  96: [
    "$workflow = :workflow :identifier :lbrace $_gen15 :rbrace -> Workflow( name=$1, body=$3 )",
  ],
  97: [
    "$string_piece = :string",
    "$string_piece = $expression_placeholder",
  ],
  98: [
    "$task_sections = $command",
    "$task_sections = $inputs",
    "$task_sections = $outputs",
    "$task_sections = $runtime",
    "$task_sections = $parameter_meta",
    "$task_sections = $meta",
    "$task_sections = $declaration",
  ],
  99: [
    "$parameter_meta = :parameter_meta $meta_map -> ParameterMeta( map=$1 )",
  ],
  100: [
    "$meta_map = :lbrace $_gen12 :rbrace -> $1",
  ],
  101: [
    "$map_kv = $e :colon $e -> MapLiteralKv( key=$0, value=$2 )",
  ],
  102: [
    "$_gen22 = list($type_e, :comma)",
  ],
  103: [
    "$_gen13 = $setter",
    "$_gen13 = :_empty",
  ],
  104: [
    "$_gen18 = $call_body",
    "$_gen18 = :_empty",
  ],
  105: [
    "$wf_meta = :meta $meta_map -> Meta( map=$1 )",
  ],
  106: [
    "$_gen3 = :string",
    "$_gen3 = :_empty",
  ],
  107: [
    "$_gen2 = list($struct_declaration)",
  ],
  108: [
    "$_gen0 = list($import)",
  ],
  109: [
    "$wf_parameter_meta = :parameter_meta $meta_map -> ParameterMeta( map=$1 )",
  ],
  110: [
    "$version = :version :version_name -> VersionDeclaration( v=$1 )",
  ],
  111: [
    "$_gen23 = list($e, :comma)",
  ],
  112: [
    "$call_brace_block = :lbrace $_gen18 :rbrace -> $1",
  ],
  113: [
    "$wf_body_element = $call",
    "$wf_body_element = $declaration",
    "$wf_body_element = $while_loop",
    "$wf_body_element = $if_stmt",
    "$wf_body_element = $scatter",
    "$wf_body_element = $inputs",
    "$wf_body_element = $outputs",
    "$wf_body_element = $wf_parameter_meta",
    "$wf_body_element = $wf_meta",
  ],
  114: [
    "$_gen12 = list($meta_kv)",
  ],
  115: [
    "$_gen1 = list($file_body_element)",
  ],
  116: [
    "$_gen7 = list($task_sections)",
  ],
  117: [
    "$_gen11 = list($kv)",
  ],
  118: [
    "$alias = :as :identifier -> $1",
  ],
  119: [
    "$_gen16 = $alias",
    "$_gen16 = :_empty",
  ],
  120: [
    "$scatter = :scatter :lparen :identifier :in $e :rparen :lbrace $_gen15 :rbrace -> Scatter( item=$2, collection=$4, body=$7 )",
  ],
  121: [
    "$struct = :struct :identifier :lbrace $_gen2 :rbrace -> Struct( name=$1, entries=$3 )",
  ],
  122: [
    "$meta_kv = :identifier :colon $meta_value -> MetaKvPair( key=$0, value=$2 )",
  ],
  123: [
    "$rt_map = :lbrace $_gen11 :rbrace -> $1",
  ],
  124: [
    "$expression_placeholder_kv = :cmd_attr_hint :identifier :equal $e -> ExpressionPlaceholderAttr( key=$1, value=$3 )",
  ],
  125: [
    "$kv = :identifier :colon $e -> RuntimeAttribute( key=$0, value=$2 )",
  ],
  126: [
    "$input_kv = :identifier :equal $e -> ObjectKV( key=$0, value=$2 )",
  ],
  127: [
    "$_gen8 = list($command_part)",
  ],
  128: [
    "$while_loop = :while :lparen $e :rparen :lbrace $_gen15 :rbrace -> WhileLoop( expression=$2, body=$5 )",
  ],
  129: [
    "$_gen19 = list($input_kv, :comma)",
  ],
  130: [
    "$if_stmt = :if :lparen $e :rparen :lbrace $_gen15 :rbrace -> If( expression=$2, body=$5 )",
  ],
  131: [
    "$file_body_element = $workflow",
    "$file_body_element = $task",
    "$file_body_element = $struct",
  ],
  132: [
    "$call = :call :fqn $_gen16 $_gen17 -> Call( task=$1, alias=$2, body=$3 )",
  ],
  133: [
    "$_gen9 = list($expression_placeholder_kv)",
  ],
  134: [
    "$declaration = $type_e :identifier $setter -> Declaration( type=$0, name=$1, expression=$2 )",
  ],
  135: [
    "$meta = :meta $meta_map -> Meta( map=$1 )",
  ],
  136: [
    "$task = :task :identifier :lbrace $_gen7 :rbrace -> Task( name=$1, sections=$3 )",
  ],
  137: [
    "$_gen20 = list($meta_value, :comma)",
  ],
}
var rules = {
  0: "$_gen0 = list($import)",
  1: "$_gen1 = list($file_body_element)",
  2: "$document = $version $_gen0 $_gen1 -> Draft3File( version=$0, imports=$1, body=$2 )",
  3: "$file_body_element = $workflow",
  4: "$file_body_element = $task",
  5: "$file_body_element = $struct",
  6: "$version = :version :version_name -> VersionDeclaration( v=$1 )",
  7: "$_gen2 = list($struct_declaration)",
  8: "$struct = :struct :identifier :lbrace $_gen2 :rbrace -> Struct( name=$1, entries=$3 )",
  9: "$struct_declaration = $type_e :identifier -> StructEntry( type=$0, name=$1 )",
  10: "$_gen3 = :string",
  11: "$_gen3 = :_empty",
  12: "$static_string = :quote $_gen3 :quote -> StaticString( value=$1 )",
  13: "$_gen4 = list($string_piece)",
  14: "$string_literal = :quote $_gen4 :quote -> StringLiteral( pieces=$1 )",
  15: "$string_piece = :string",
  16: "$string_piece = $expression_placeholder",
  17: "$_gen5 = $import_namespace",
  18: "$_gen5 = :_empty",
  19: "$_gen6 = list($import_alias)",
  20: "$import = :import $static_string $_gen5 $_gen6 -> Import( uri=$1, namespace=$2, aliases=$3 )",
  21: "$import_namespace = :as :identifier -> $1",
  22: "$import_alias = :alias :identifier :as :identifier -> ImportAlias( old_name=$1, new_name=$3 )",
  23: "$_gen7 = list($task_sections)",
  24: "$task = :task :identifier :lbrace $_gen7 :rbrace -> Task( name=$1, sections=$3 )",
  25: "$task_sections = $command",
  26: "$task_sections = $inputs",
  27: "$task_sections = $outputs",
  28: "$task_sections = $runtime",
  29: "$task_sections = $parameter_meta",
  30: "$task_sections = $meta",
  31: "$task_sections = $declaration",
  32: "$_gen8 = list($command_part)",
  33: "$command = :raw_command :raw_cmd_start $_gen8 :raw_cmd_end -> RawCommand( parts=$2 )",
  34: "$command_part = :cmd_part",
  35: "$command_part = $expression_placeholder",
  36: "$_gen9 = list($expression_placeholder_kv)",
  37: "$expression_placeholder = :expression_placeholder_start $_gen9 $e :expression_placeholder_end -> ExpressionPlaceholder( attributes=$1, expr=$2 )",
  38: "$expression_placeholder_kv = :cmd_attr_hint :identifier :equal $e -> ExpressionPlaceholderAttr( key=$1, value=$3 )",
  39: "$_gen10 = list($input_declaration)",
  40: "$inputs = :input :lbrace $_gen10 :rbrace -> Inputs( inputs=$2 )",
  41: "$runtime = :runtime $rt_map -> Runtime( map=$1 )",
  42: "$_gen11 = list($kv)",
  43: "$rt_map = :lbrace $_gen11 :rbrace -> $1",
  44: "$kv = :identifier :colon $e -> RuntimeAttribute( key=$0, value=$2 )",
  45: "$meta = :meta $meta_map -> Meta( map=$1 )",
  46: "$parameter_meta = :parameter_meta $meta_map -> ParameterMeta( map=$1 )",
  47: "$_gen12 = list($meta_kv)",
  48: "$meta_map = :lbrace $_gen12 :rbrace -> $1",
  49: "$meta_kv = :identifier :colon $meta_value -> MetaKvPair( key=$0, value=$2 )",
  50: "$_gen13 = $setter",
  51: "$_gen13 = :_empty",
  52: "$input_declaration = $type_e :identifier $_gen13 -> InputDeclaration( type=$0, name=$1, expression=$2 )",
  53: "$declaration = $type_e :identifier $setter -> Declaration( type=$0, name=$1, expression=$2 )",
  54: "$setter = :equal $e -> $1",
  55: "$map_kv = $e :colon $e -> MapLiteralKv( key=$0, value=$2 )",
  56: "$_gen14 = list($output_kv)",
  57: "$outputs = :output :lbrace $_gen14 :rbrace -> Outputs( outputs=$2 )",
  58: "$output_kv = $type_e :identifier :equal $e -> Output( type=$0, name=$1, expression=$3 )",
  59: "$_gen15 = list($wf_body_element)",
  60: "$workflow = :workflow :identifier :lbrace $_gen15 :rbrace -> Workflow( name=$1, body=$3 )",
  61: "$wf_body_element = $call",
  62: "$wf_body_element = $declaration",
  63: "$wf_body_element = $while_loop",
  64: "$wf_body_element = $if_stmt",
  65: "$wf_body_element = $scatter",
  66: "$wf_body_element = $inputs",
  67: "$wf_body_element = $outputs",
  68: "$wf_body_element = $wf_parameter_meta",
  69: "$wf_body_element = $wf_meta",
  70: "$_gen16 = $alias",
  71: "$_gen16 = :_empty",
  72: "$_gen17 = $call_brace_block",
  73: "$_gen17 = :_empty",
  74: "$call = :call :fqn $_gen16 $_gen17 -> Call( task=$1, alias=$2, body=$3 )",
  75: "$_gen18 = $call_body",
  76: "$_gen18 = :_empty",
  77: "$call_brace_block = :lbrace $_gen18 :rbrace -> $1",
  78: "$_gen19 = list($input_kv, :comma)",
  79: "$call_body = :input :colon $_gen19 -> CallBody( inputs=$2 )",
  80: "$alias = :as :identifier -> $1",
  81: "$wf_parameter_meta = :parameter_meta $meta_map -> ParameterMeta( map=$1 )",
  82: "$wf_meta = :meta $meta_map -> Meta( map=$1 )",
  83: "$while_loop = :while :lparen $e :rparen :lbrace $_gen15 :rbrace -> WhileLoop( expression=$2, body=$5 )",
  84: "$if_stmt = :if :lparen $e :rparen :lbrace $_gen15 :rbrace -> If( expression=$2, body=$5 )",
  85: "$scatter = :scatter :lparen :identifier :in $e :rparen :lbrace $_gen15 :rbrace -> Scatter( item=$2, collection=$4, body=$7 )",
  86: "$object_kv = :identifier :colon $e -> ObjectKV( key=$0, value=$2 )",
  87: "$input_kv = :identifier :equal $e -> ObjectKV( key=$0, value=$2 )",
  88: "$meta_value = $static_string",
  89: "$meta_value = :boolean",
  90: "$meta_value = :integer",
  91: "$meta_value = :float",
  92: "$meta_value = :null",
  93: "$_gen20 = list($meta_value, :comma)",
  94: "$meta_value = :lsquare $_gen20 :rsquare -> MetaArray( values=$1 )",
  95: "$_gen21 = list($meta_kv, :comma)",
  96: "$meta_value = :lbrace $_gen21 :rbrace -> MetaObject( map=$1 )",
  97: "$_gen22 = list($type_e, :comma)",
  98: "$type_e = :type <=> :lsquare $_gen22 :rsquare -> Type( name=$0, subtype=$2 )",
  99: "$type_e = :type <=> :qmark -> OptionalType( innerType=$0 )",
  100: "$type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )",
  101: "$type_e = :type",
  102: "$type_e = :identifier",
  103: "$e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )",
  104: "$e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )",
  105: "$e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )",
  106: "$e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )",
  107: "$e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )",
  108: "$e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )",
  109: "$e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )",
  110: "$e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )",
  111: "$e = $e :plus $e -> Add( lhs=$0, rhs=$2 )",
  112: "$e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )",
  113: "$e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )",
  114: "$e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )",
  115: "$e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )",
  116: "$e = :not $e -> LogicalNot( expression=$1 )",
  117: "$e = :plus $e -> UnaryPlus( expression=$1 )",
  118: "$e = :dash $e -> UnaryNegation( expression=$1 )",
  119: "$_gen23 = list($e, :comma)",
  120: "$e = :identifier <=> :lparen $_gen23 :rparen -> FunctionCall( name=$0, params=$2 )",
  121: "$e = $e <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )",
  122: "$e = $e <=> :dot :identifier -> MemberAccess( value=$0, member=$2 )",
  123: "$_gen24 = list($object_kv, :comma)",
  124: "$e = :object :lbrace $_gen24 :rbrace -> ObjectLiteral( map=$2 )",
  125: "$e = :lsquare $_gen23 :rsquare -> ArrayLiteral( values=$1 )",
  126: "$_gen25 = list($map_kv, :comma)",
  127: "$e = :lbrace $_gen25 :rbrace -> MapLiteral( map=$1 )",
  128: "$e = :lparen $_gen23 :rparen -> TupleLiteral( values=$1 )",
  129: "$e = :if $e :then $e :else $e -> TernaryIf( cond=$1, iftrue=$3, iffalse=$5 )",
  130: "$e = $string_literal",
  131: "$e = :identifier",
  132: "$e = :boolean",
  133: "$e = :integer",
  134: "$e = :float",
}
function is_terminal(id){
  return 0 <= id && id <= 64;
}
function parse(tokens, error_formatter, start) {
  if (error_formatter === undefined) {
    error_formatter = new DefaultSyntaxErrorFormatter();
  }
  var ctx = new ParserContext(tokens, error_formatter);
  var tree = parse_document(ctx);
  if (tokens.current() != null) {
    throw new SyntaxError('Finished parsing without consuming all tokens.');
  }
  return tree;
}
function expect(ctx, terminal_id) {
  var current = ctx.tokens.current();
  if (current == null) {
    throw new SyntaxError(ctx.error_formatter.no_more_tokens(ctx.nonterminal, terminals[terminal_id], ctx.tokens.last()));
  }
  if (current.id != terminal_id) {
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(ctx.nonterminal, current, [terminals[terminal_id]], ctx.rule));
  }
  var next = ctx.tokens.advance();
  if (next && !is_terminal(next.id)) {
    throw new SyntaxError(ctx.error_formatter.invalid_terminal(ctx.nonterminal, next));
  }
  return current;
}
// START definitions for expression parser `e`
var infix_binding_power_e = {
  43: 4000, // $e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )
  64: 5000, // $e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )
  14: 6000, // $e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )
  20: 6000, // $e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )
  2: 7000, // $e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )
  25: 7000, // $e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )
  26: 7000, // $e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )
  53: 7000, // $e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )
  24: 8000, // $e = $e :plus $e -> Add( lhs=$0, rhs=$2 )
  13: 8000, // $e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )
  32: 9000, // $e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )
  44: 9000, // $e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )
  39: 9000, // $e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )
  51: 11000, // $e = :identifier <=> :lparen list($e, :comma) :rparen -> FunctionCall( name=$0, params=$2 )
  41: 12000, // $e = $e <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )
  9: 13000, // $e = $e <=> :dot :identifier -> MemberAccess( value=$0, member=$2 )
}
var prefix_binding_power_e = {
  12: 10000, // $e = :not $e -> LogicalNot( expression=$1 )
  24: 10000, // $e = :plus $e -> UnaryPlus( expression=$1 )
  13: 10000, // $e = :dash $e -> UnaryNegation( expression=$1 )
}
function get_infix_binding_power_e(terminal_id) {
  if (terminal_id in infix_binding_power_e) {
    return infix_binding_power_e[terminal_id];
  } else {
    return 0;
  }
}
function get_prefix_binding_power_e(terminal_id) {
  if (terminal_id in prefix_binding_power_e) {
    return prefix_binding_power_e[terminal_id];
  } else {
    return 0;
  }
}
function parse_e(ctx) {
  return parse_e_internal(ctx, 0);
}
function parse_e_internal(ctx, rbp) {
  var left = nud_e(ctx);
  if (left instanceof ParseTree) {
    left.isExpr = true;
    left.isNud = true;
  }
  while (ctx.tokens.current() && rbp < get_infix_binding_power_e(ctx.tokens.current().id)) {
    left = led_e(left, ctx);
  }
  if (left) {
    left.isExpr = true;
  }
  return left;
}
function nud_e(ctx) {
  var tree = new ParseTree(new NonTerminal(94, 'e'));
  var current = ctx.tokens.current();
  var ast_parameters;
  ctx.nonterminal = "e";
  if (!current) {
    return tree;
  } else if (rule_first[116].indexOf(current.id) != -1) {
    // $e = :not $e -> LogicalNot( expression=$1 )
    ctx.rule = rules[116];
    ast_parameters = {
      'expression': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('LogicalNot', ast_parameters);
    tree.nudMorphemeCount = 2;
    tree.add(expect(ctx, 12));
    tree.add(parse_e_internal(ctx, get_prefix_binding_power_e(12)));
    tree.isPrefix = true;
  } else if (rule_first[117].indexOf(current.id) != -1) {
    // $e = :plus $e -> UnaryPlus( expression=$1 )
    ctx.rule = rules[117];
    ast_parameters = {
      'expression': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('UnaryPlus', ast_parameters);
    tree.nudMorphemeCount = 2;
    tree.add(expect(ctx, 24));
    tree.add(parse_e_internal(ctx, get_prefix_binding_power_e(24)));
    tree.isPrefix = true;
  } else if (rule_first[118].indexOf(current.id) != -1) {
    // $e = :dash $e -> UnaryNegation( expression=$1 )
    ctx.rule = rules[118];
    ast_parameters = {
      'expression': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('UnaryNegation', ast_parameters);
    tree.nudMorphemeCount = 2;
    tree.add(expect(ctx, 13));
    tree.add(parse_e_internal(ctx, get_prefix_binding_power_e(13)));
    tree.isPrefix = true;
  } else if (rule_first[120].indexOf(current.id) != -1) {
    // $e = :identifier <=> :lparen $_gen23 :rparen -> FunctionCall( name=$0, params=$2 )
    ctx.rule = rules[120];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 37));
  } else if (rule_first[124].indexOf(current.id) != -1) {
    // $e = :object :lbrace $_gen24 :rbrace -> ObjectLiteral( map=$2 )
    ctx.rule = rules[124];
    ast_parameters = {
      'map': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('ObjectLiteral', ast_parameters);
    tree.nudMorphemeCount = 4;
    tree.add(expect(ctx, 54));
    tree.add(expect(ctx, 34));
    tree.add(parse__gen24(ctx));
    tree.add(expect(ctx, 62));
  } else if (rule_first[125].indexOf(current.id) != -1) {
    // $e = :lsquare $_gen23 :rsquare -> ArrayLiteral( values=$1 )
    ctx.rule = rules[125];
    ast_parameters = {
      'values': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('ArrayLiteral', ast_parameters);
    tree.nudMorphemeCount = 3;
    tree.add(expect(ctx, 41));
    tree.add(parse__gen23(ctx));
    tree.add(expect(ctx, 58));
  } else if (rule_first[127].indexOf(current.id) != -1) {
    // $e = :lbrace $_gen25 :rbrace -> MapLiteral( map=$1 )
    ctx.rule = rules[127];
    ast_parameters = {
      'map': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('MapLiteral', ast_parameters);
    tree.nudMorphemeCount = 3;
    tree.add(expect(ctx, 34));
    tree.add(parse__gen25(ctx));
    tree.add(expect(ctx, 62));
  } else if (rule_first[128].indexOf(current.id) != -1) {
    // $e = :lparen $_gen23 :rparen -> TupleLiteral( values=$1 )
    ctx.rule = rules[128];
    ast_parameters = {
      'values': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('TupleLiteral', ast_parameters);
    tree.nudMorphemeCount = 3;
    tree.add(expect(ctx, 51));
    tree.add(parse__gen23(ctx));
    tree.add(expect(ctx, 1));
  } else if (rule_first[129].indexOf(current.id) != -1) {
    // $e = :if $e :then $e :else $e -> TernaryIf( cond=$1, iftrue=$3, iffalse=$5 )
    ctx.rule = rules[129];
    ast_parameters = {
      'cond': 1,
      'iftrue': 3,
      'iffalse': 5,
    }
    tree.astTransform = new AstTransformNodeCreator('TernaryIf', ast_parameters);
    tree.nudMorphemeCount = 6;
    tree.add(expect(ctx, 48));
    tree.add(parse_e(ctx));
    tree.add(expect(ctx, 56));
    tree.add(parse_e(ctx));
    tree.add(expect(ctx, 17));
    tree.add(parse_e(ctx));
  } else if (rule_first[130].indexOf(current.id) != -1) {
    // $e = $string_literal
    ctx.rule = rules[130];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(parse_string_literal(ctx));
  } else if (rule_first[131].indexOf(current.id) != -1) {
    // $e = :identifier
    ctx.rule = rules[131];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 37));
  } else if (rule_first[132].indexOf(current.id) != -1) {
    // $e = :boolean
    ctx.rule = rules[132];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 3));
  } else if (rule_first[133].indexOf(current.id) != -1) {
    // $e = :integer
    ctx.rule = rules[133];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 15));
  } else if (rule_first[134].indexOf(current.id) != -1) {
    // $e = :float
    ctx.rule = rules[134];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 33));
  }
  return tree;
}
function led_e(left, ctx) {
  var tree = new ParseTree(new NonTerminal(94, 'e'))
  var current = ctx.tokens.current()
  var ast_parameters;
  ctx.nonterminal = "e";
  if (current.id == 43) { // :double_pipe
    // $e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )
    ctx.rule = rules[103];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('LogicalOr', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 43)); // :double_pipe
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(43) - modifier));
  }
  if (current.id == 64) { // :double_ampersand
    // $e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )
    ctx.rule = rules[104];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('LogicalAnd', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 64)); // :double_ampersand
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(64) - modifier));
  }
  if (current.id == 14) { // :double_equal
    // $e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )
    ctx.rule = rules[105];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Equals', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 14)); // :double_equal
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(14) - modifier));
  }
  if (current.id == 20) { // :not_equal
    // $e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )
    ctx.rule = rules[106];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('NotEquals', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 20)); // :not_equal
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(20) - modifier));
  }
  if (current.id == 2) { // :lt
    // $e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )
    ctx.rule = rules[107];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('LessThan', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 2)); // :lt
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(2) - modifier));
  }
  if (current.id == 25) { // :lteq
    // $e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )
    ctx.rule = rules[108];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('LessThanOrEqual', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 25)); // :lteq
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(25) - modifier));
  }
  if (current.id == 26) { // :gt
    // $e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )
    ctx.rule = rules[109];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('GreaterThan', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 26)); // :gt
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(26) - modifier));
  }
  if (current.id == 53) { // :gteq
    // $e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )
    ctx.rule = rules[110];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('GreaterThanOrEqual', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 53)); // :gteq
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(53) - modifier));
  }
  if (current.id == 24) { // :plus
    // $e = $e :plus $e -> Add( lhs=$0, rhs=$2 )
    ctx.rule = rules[111];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Add', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 24)); // :plus
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(24) - modifier));
  }
  if (current.id == 13) { // :dash
    // $e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )
    ctx.rule = rules[112];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Subtract', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 13)); // :dash
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(13) - modifier));
  }
  if (current.id == 32) { // :asterisk
    // $e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )
    ctx.rule = rules[113];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Multiply', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 32)); // :asterisk
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(32) - modifier));
  }
  if (current.id == 44) { // :slash
    // $e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )
    ctx.rule = rules[114];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Divide', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 44)); // :slash
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(44) - modifier));
  }
  if (current.id == 39) { // :percent
    // $e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )
    ctx.rule = rules[115];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Remainder', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 39)); // :percent
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(39) - modifier));
  }
  if (current.id == 51) { // :lparen
    // $e = :identifier <=> :lparen $_gen23 :rparen -> FunctionCall( name=$0, params=$2 )
    ctx.rule = rules[120];
    ast_parameters = {
      'name': 0,
      'params': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('FunctionCall', ast_parameters);
    tree.add(left);
    tree.add(expect(ctx, 51)); // :lparen
    tree.add(parse__gen23(ctx));
    tree.add(expect(ctx, 1)); // :rparen
  }
  if (current.id == 41) { // :lsquare
    // $e = $e <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )
    ctx.rule = rules[121];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('ArrayOrMapLookup', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 41)); // :lsquare
    var modifier = 0;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(41) - modifier));
    tree.add(expect(ctx, 58)); // :rsquare
  }
  if (current.id == 9) { // :dot
    // $e = $e <=> :dot :identifier -> MemberAccess( value=$0, member=$2 )
    ctx.rule = rules[122];
    ast_parameters = {
      'value': 0,
      'member': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('MemberAccess', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 9)); // :dot
    tree.add(expect(ctx, 37)); // :identifier
  }
  return tree;
}
// END definitions for expression parser `e`
// START definitions for expression parser `meta_value`
var infix_binding_power_meta_value = {}
var prefix_binding_power_meta_value = {}

function get_infix_binding_power_meta_value(terminal_id) {
  if (terminal_id in infix_binding_power_meta_value) {
    return infix_binding_power_meta_value[terminal_id];
  } else {
    return 0;
  }
}
function get_prefix_binding_power_meta_value(terminal_id) {
  if (terminal_id in prefix_binding_power_meta_value) {
    return prefix_binding_power_meta_value[terminal_id];
  } else {
    return 0;
  }
}
function parse_meta_value(ctx) {
  return parse_meta_value_internal(ctx, 0);
}
function parse_meta_value_internal(ctx, rbp) {
  var left = nud_meta_value(ctx);
  if (left instanceof ParseTree) {
    left.isExpr = true;
    left.isNud = true;
  }
  while (ctx.tokens.current() && rbp < get_infix_binding_power_meta_value(ctx.tokens.current().id)) {
    left = led_meta_value(left, ctx);
  }
  if (left) {
    left.isExpr = true;
  }
  return left;
}
function nud_meta_value(ctx) {
  var tree = new ParseTree(new NonTerminal(68, 'meta_value'));
  var current = ctx.tokens.current();
  ctx.nonterminal = "meta_value";
  if (!current) {
    return tree;
  }
  if (rule_first[88].indexOf(current.id) != -1) {
    // $meta_value = $static_string
    ctx.rule = rules[88];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(parse_static_string(ctx));
  } else if (rule_first[89].indexOf(current.id) != -1) {
    // $meta_value = :boolean
    ctx.rule = rules[89];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 3));
  } else if (rule_first[90].indexOf(current.id) != -1) {
    // $meta_value = :integer
    ctx.rule = rules[90];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 15));
  } else if (rule_first[91].indexOf(current.id) != -1) {
    // $meta_value = :float
    ctx.rule = rules[91];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 33));
  } else if (rule_first[92].indexOf(current.id) != -1) {
    // $meta_value = :null
    ctx.rule = rules[92];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 52));
  } else if (rule_first[94].indexOf(current.id) != -1) {
    // $meta_value = :lsquare $_gen20 :rsquare -> MetaArray( values=$1 )
    ctx.rule = rules[94];
    ast_parameters = {
      'values': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('MetaArray', ast_parameters);
    tree.nudMorphemeCount = 3;
    tree.add(expect(ctx, 41));
    tree.add(parse__gen20(ctx));
    tree.add(expect(ctx, 58));
  } else if (rule_first[96].indexOf(current.id) != -1) {
    // $meta_value = :lbrace $_gen21 :rbrace -> MetaObject( map=$1 )
    ctx.rule = rules[96];
    ast_parameters = {
      'map': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('MetaObject', ast_parameters);
    tree.nudMorphemeCount = 3;
    tree.add(expect(ctx, 34));
    tree.add(parse__gen21(ctx));
    tree.add(expect(ctx, 62));
  }
  return tree;
}
function led_meta_value(left, ctx) {
  var tree = new ParseTree(new NonTerminal(68, 'meta_value'))
  var current = ctx.tokens.current()
  ctx.nonterminal = "meta_value";
  return tree;
}
// END definitions for expression parser `meta_value`
// START definitions for expression parser `type_e`
var infix_binding_power_type_e = {
  41: 1000, // $type_e = :type <=> :lsquare list($type_e, :comma) :rsquare -> Type( name=$0, subtype=$2 )
  38: 2000, // $type_e = :type <=> :qmark -> OptionalType( innerType=$0 )
  24: 3000, // $type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )
}
var prefix_binding_power_type_e = {
}
function get_infix_binding_power_type_e(terminal_id) {
  if (terminal_id in infix_binding_power_type_e) {
    return infix_binding_power_type_e[terminal_id];
  } else {
    return 0;
  }
}
function get_prefix_binding_power_type_e(terminal_id) {
  if (terminal_id in prefix_binding_power_type_e) {
    return prefix_binding_power_type_e[terminal_id];
  } else {
    return 0;
  }
}
function parse_type_e(ctx) {
  return parse_type_e_internal(ctx, 0);
}
function parse_type_e_internal(ctx, rbp) {
  var left = nud_type_e(ctx);
  if (left instanceof ParseTree) {
    left.isExpr = true;
    left.isNud = true;
  }
  while (ctx.tokens.current() && rbp < get_infix_binding_power_type_e(ctx.tokens.current().id)) {
    left = led_type_e(left, ctx);
  }
  if (left) {
    left.isExpr = true;
  }
  return left;
}
function nud_type_e(ctx) {
  var tree = new ParseTree(new NonTerminal(76, 'type_e'));
  var current = ctx.tokens.current();
  var ast_parameters;
  ctx.nonterminal = "type_e";
  if (!current) {
    return tree;
  }
  if (rule_first[98].indexOf(current.id) != -1) {
    // $type_e = :type <=> :lsquare $_gen22 :rsquare -> Type( name=$0, subtype=$2 )
    ctx.rule = rules[98];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 57));
  } else if (rule_first[99].indexOf(current.id) != -1) {
    // $type_e = :type <=> :qmark -> OptionalType( innerType=$0 )
    ctx.rule = rules[99];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 57));
  } else if (rule_first[100].indexOf(current.id) != -1) {
    // $type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )
    ctx.rule = rules[100];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 57));
  } else if (rule_first[101].indexOf(current.id) != -1) {
    // $type_e = :type
    ctx.rule = rules[101];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 57));
  } else if (rule_first[102].indexOf(current.id) != -1) {
    // $type_e = :identifier
    ctx.rule = rules[102];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 37));
  }
  return tree;
}
function led_type_e(left, ctx) {
  var tree = new ParseTree(new NonTerminal(76, 'type_e'))
  var current = ctx.tokens.current()
  var ast_parameters;
  ctx.nonterminal = "type_e";
  if (current.id == 41) { // :lsquare
    // $type_e = :type <=> :lsquare $_gen22 :rsquare -> Type( name=$0, subtype=$2 )
    ctx.rule = rules[98];
    ast_parameters = {
      'name': 0,
      'subtype': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Type', ast_parameters);
    tree.add(left);
    tree.add(expect(ctx, 41)); // :lsquare
    tree.add(parse__gen22(ctx));
    tree.add(expect(ctx, 58)); // :rsquare
  }
  if (current.id == 38) { // :qmark
    // $type_e = :type <=> :qmark -> OptionalType( innerType=$0 )
    ctx.rule = rules[99];
    ast_parameters = {
      'innerType': 0,
    }
    tree.astTransform = new AstTransformNodeCreator('OptionalType', ast_parameters);
    tree.add(left);
    tree.add(expect(ctx, 38)); // :qmark
  }
  if (current.id == 24) { // :plus
    // $type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )
    ctx.rule = rules[100];
    ast_parameters = {
      'innerType': 0,
    }
    tree.astTransform = new AstTransformNodeCreator('NonEmptyType', ast_parameters);
    tree.add(left);
    tree.add(expect(ctx, 24)); // :plus
  }
  return tree;
}
// END definitions for expression parser `type_e`
function parse__gen0(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[43][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(108, '_gen0'));
  ctx.nonterminal = "_gen0";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[108].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[108].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
    nonterminal_first[108].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_import(ctx));
    ctx.nonterminal = "_gen0";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen1(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[50][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(115, '_gen1'));
  ctx.nonterminal = "_gen1";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[115].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[115].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[115].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_file_body_element(ctx));
    ctx.nonterminal = "_gen1";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen10(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[1][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(66, '_gen10'));
  ctx.nonterminal = "_gen10";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[66].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[66].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[66].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_input_declaration(ctx));
    ctx.nonterminal = "_gen10";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen11(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[52][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(117, '_gen11'));
  ctx.nonterminal = "_gen11";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[117].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[117].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[117].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_kv(ctx));
    ctx.nonterminal = "_gen11";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen12(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[49][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(114, '_gen12'));
  ctx.nonterminal = "_gen12";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[114].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[114].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
    nonterminal_first[114].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_meta_kv(ctx));
    ctx.nonterminal = "_gen12";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen14(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[20][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(85, '_gen14'));
  ctx.nonterminal = "_gen14";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[85].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[85].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
    nonterminal_first[85].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_output_kv(ctx));
    ctx.nonterminal = "_gen14";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen15(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[21][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(86, '_gen15'));
  ctx.nonterminal = "_gen15";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[86].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[86].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
    nonterminal_first[86].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_wf_body_element(ctx));
    ctx.nonterminal = "_gen15";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen19(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[64][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(129, '_gen19'));
  ctx.nonterminal = "_gen19";
  tree.list = true;
  tree.listSeparator = 28;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[129].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[129].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
    nonterminal_first[129].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_input_kv(ctx));
    ctx.nonterminal = "_gen19";
    if (ctx.tokens.current() != null && ctx.tokens.current().id == 28) {
      tree.add(expect(ctx, 28));
    } else {
      if (minimum > 1) {
        throw new SyntaxError(ctx.error_formatter.missing_list_items(
          "_gen19",
          0,
          0 - minimum + 1,
          null
        ));
      }
      break;
    }
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen2(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[42][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(107, '_gen2'));
  ctx.nonterminal = "_gen2";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[107].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[107].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[107].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_struct_declaration(ctx));
    ctx.nonterminal = "_gen2";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen20(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[72][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(137, '_gen20'));
  ctx.nonterminal = "_gen20";
  tree.list = true;
  tree.listSeparator = 28;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[137].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[137].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[137].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_meta_value(ctx));
    ctx.nonterminal = "_gen20";
    if (ctx.tokens.current() != null && ctx.tokens.current().id == 28) {
      tree.add(expect(ctx, 28));
    } else {
      if (minimum > 1) {
        throw new SyntaxError(ctx.error_formatter.missing_list_items(
          "_gen20",
          0,
          0 - minimum + 1,
          null
        ));
      }
      break;
    }
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen21(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[28][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(93, '_gen21'));
  ctx.nonterminal = "_gen21";
  tree.list = true;
  tree.listSeparator = 28;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[93].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[93].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[93].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_meta_kv(ctx));
    ctx.nonterminal = "_gen21";
    if (ctx.tokens.current() != null && ctx.tokens.current().id == 28) {
      tree.add(expect(ctx, 28));
    } else {
      if (minimum > 1) {
        throw new SyntaxError(ctx.error_formatter.missing_list_items(
          "_gen21",
          0,
          0 - minimum + 1,
          null
        ));
      }
      break;
    }
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen22(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[37][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(102, '_gen22'));
  ctx.nonterminal = "_gen22";
  tree.list = true;
  tree.listSeparator = 28;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[102].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[102].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[102].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_type_e(ctx));
    ctx.nonterminal = "_gen22";
    if (ctx.tokens.current() != null && ctx.tokens.current().id == 28) {
      tree.add(expect(ctx, 28));
    } else {
      if (minimum > 1) {
        throw new SyntaxError(ctx.error_formatter.missing_list_items(
          "_gen22",
          0,
          0 - minimum + 1,
          null
        ));
      }
      break;
    }
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen23(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[46][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(111, '_gen23'));
  ctx.nonterminal = "_gen23";
  tree.list = true;
  tree.listSeparator = 28;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[111].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[111].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[111].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_e(ctx));
    ctx.nonterminal = "_gen23";
    if (ctx.tokens.current() != null && ctx.tokens.current().id == 28) {
      tree.add(expect(ctx, 28));
    } else {
      if (minimum > 1) {
        throw new SyntaxError(ctx.error_formatter.missing_list_items(
          "_gen23",
          0,
          0 - minimum + 1,
          null
        ));
      }
      break;
    }
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen24(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[23][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(88, '_gen24'));
  ctx.nonterminal = "_gen24";
  tree.list = true;
  tree.listSeparator = 28;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[88].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[88].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[88].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_object_kv(ctx));
    ctx.nonterminal = "_gen24";
    if (ctx.tokens.current() != null && ctx.tokens.current().id == 28) {
      tree.add(expect(ctx, 28));
    } else {
      if (minimum > 1) {
        throw new SyntaxError(ctx.error_formatter.missing_list_items(
          "_gen24",
          0,
          0 - minimum + 1,
          null
        ));
      }
      break;
    }
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen25(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[25][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(90, '_gen25'));
  ctx.nonterminal = "_gen25";
  tree.list = true;
  tree.listSeparator = 28;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[90].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[90].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[90].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_map_kv(ctx));
    ctx.nonterminal = "_gen25";
    if (ctx.tokens.current() != null && ctx.tokens.current().id == 28) {
      tree.add(expect(ctx, 28));
    } else {
      if (minimum > 1) {
        throw new SyntaxError(ctx.error_formatter.missing_list_items(
          "_gen25",
          0,
          0 - minimum + 1,
          null
        ));
      }
      break;
    }
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen4(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[6][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(71, '_gen4'));
  ctx.nonterminal = "_gen4";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[71].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[71].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[71].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_string_piece(ctx));
    ctx.nonterminal = "_gen4";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen6(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[12][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(77, '_gen6'));
  ctx.nonterminal = "_gen6";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[77].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[77].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[77].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_import_alias(ctx));
    ctx.nonterminal = "_gen6";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen7(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[51][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(116, '_gen7'));
  ctx.nonterminal = "_gen7";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[116].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[116].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[116].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_task_sections(ctx));
    ctx.nonterminal = "_gen7";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen8(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[62][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(127, '_gen8'));
  ctx.nonterminal = "_gen8";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[127].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[127].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[127].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_command_part(ctx));
    ctx.nonterminal = "_gen8";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen9(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[68][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(133, '_gen9'));
  ctx.nonterminal = "_gen9";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if (ctx.tokens.current() != null &&
    nonterminal_follow[133].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[133].indexOf(ctx.tokens.current().id) == -1) {
    return tree;
  }
  if (ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while (minimum > 0 ||
  (ctx.tokens.current() != null &&
    nonterminal_first[133].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_expression_placeholder_kv(ctx));
    ctx.nonterminal = "_gen9";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen13(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[38][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(103, '_gen13'));
  var subtree;
  ctx.nonterminal = "_gen13";
  if (current != null && nonterminal_follow[103].indexOf(current.id) != -1 && nonterminal_first[103].indexOf(current.id) == -1) {
    return tree;
  }
  if (current == null) {
    return tree;
  }
  if (rule == 50) { // $_gen13 = $setter
    ctx.rule = rules[50];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_setter(ctx);
    tree.add(subtree);
    return tree;
  }
  return tree;
}
function parse__gen16(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[54][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(119, '_gen16'));
  var subtree;
  ctx.nonterminal = "_gen16";
  if (current != null && nonterminal_follow[119].indexOf(current.id) != -1 && nonterminal_first[119].indexOf(current.id) == -1) {
    return tree;
  }
  if (current == null) {
    return tree;
  }
  if (rule == 70) { // $_gen16 = $alias
    ctx.rule = rules[70];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_alias(ctx);
    tree.add(subtree);
    return tree;
  }
  return tree;
}
function parse__gen17(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[0][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(65, '_gen17'));
  var subtree;
  ctx.nonterminal = "_gen17";
  if (current != null && nonterminal_follow[65].indexOf(current.id) != -1 && nonterminal_first[65].indexOf(current.id) == -1) {
    return tree;
  }
  if (current == null) {
    return tree;
  }
  if (rule == 72) { // $_gen17 = $call_brace_block
    ctx.rule = rules[72];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_call_brace_block(ctx);
    tree.add(subtree);
    return tree;
  }
  return tree;
}
function parse__gen18(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[39][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(104, '_gen18'));
  var subtree;
  ctx.nonterminal = "_gen18";
  if (current != null && nonterminal_follow[104].indexOf(current.id) != -1 && nonterminal_first[104].indexOf(current.id) == -1) {
    return tree;
  }
  if (current == null) {
    return tree;
  }
  if (rule == 75) { // $_gen18 = $call_body
    ctx.rule = rules[75];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_call_body(ctx);
    tree.add(subtree);
    return tree;
  }
  return tree;
}
function parse__gen3(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[41][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(106, '_gen3'));
  var t;
  ctx.nonterminal = "_gen3";
  if (current != null && nonterminal_follow[106].indexOf(current.id) != -1 && nonterminal_first[106].indexOf(current.id) == -1) {
    return tree;
  }
  if (current == null) {
    return tree;
  }
  if (rule == 10) { // $_gen3 = :string
    ctx.rule = rules[10];
    tree.astTransform = new AstTransformSubstitution(0);
    t = expect(ctx, 47); // :string
    tree.add(t);
    return tree;
  }
  return tree;
}
function parse__gen5(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[7][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(72, '_gen5'));
  var subtree;
  ctx.nonterminal = "_gen5";
  if (current != null && nonterminal_follow[72].indexOf(current.id) != -1 && nonterminal_first[72].indexOf(current.id) == -1) {
    return tree;
  }
  if (current == null) {
    return tree;
  }
  if (rule == 17) { // $_gen5 = $import_namespace
    ctx.rule = rules[17];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_import_namespace(ctx);
    tree.add(subtree);
    return tree;
  }
  return tree;
}
function parse_alias(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[53][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(118, 'alias'));
  var t;
  ctx.nonterminal = "alias";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 80) { // $alias = :as :identifier -> $1
    ctx.rule = rules[80];
    tree.astTransform = new AstTransformSubstitution(1);
    t = expect(ctx, 59); // :as
    tree.add(t);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[118],
    rules[80]
  ));
}
function parse_call(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[67][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(132, 'call'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "call";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 74) { // $call = :call :fqn $_gen16 $_gen17 -> Call( task=$1, alias=$2, body=$3 )
    ctx.rule = rules[74];
    ast_parameters = {
      'task': 1,
      'alias': 2,
      'body': 3,
    }
    tree.astTransform = new AstTransformNodeCreator('Call', ast_parameters);
    t = expect(ctx, 31); // :call
    tree.add(t);
    t = expect(ctx, 16); // :fqn
    tree.add(t);
    subtree = parse__gen16(ctx);
    tree.add(subtree);
    subtree = parse__gen17(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[132],
    rules[74]
  ));
}
function parse_call_body(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[22][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(87, 'call_body'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "call_body";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 79) { // $call_body = :input :colon $_gen19 -> CallBody( inputs=$2 )
    ctx.rule = rules[79];
    ast_parameters = {
      'inputs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('CallBody', ast_parameters);
    t = expect(ctx, 42); // :input
    tree.add(t);
    t = expect(ctx, 27); // :colon
    tree.add(t);
    subtree = parse__gen19(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[87],
    rules[79]
  ));
}
function parse_call_brace_block(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[47][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(112, 'call_brace_block'));
  var subtree;
  var t;
  ctx.nonterminal = "call_brace_block";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 77) { // $call_brace_block = :lbrace $_gen18 :rbrace -> $1
    ctx.rule = rules[77];
    tree.astTransform = new AstTransformSubstitution(1);
    t = expect(ctx, 34); // :lbrace
    tree.add(t);
    subtree = parse__gen18(ctx);
    tree.add(subtree);
    t = expect(ctx, 62); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[112],
    rules[77]
  ));
}
function parse_command(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[30][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(95, 'command'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "command";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 33) { // $command = :raw_command :raw_cmd_start $_gen8 :raw_cmd_end -> RawCommand( parts=$2 )
    ctx.rule = rules[33];
    ast_parameters = {
      'parts': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('RawCommand', ast_parameters);
    t = expect(ctx, 29); // :raw_command
    tree.add(t);
    t = expect(ctx, 7); // :raw_cmd_start
    tree.add(t);
    subtree = parse__gen8(ctx);
    tree.add(subtree);
    t = expect(ctx, 6); // :raw_cmd_end
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[95],
    rules[33]
  ));
}
function parse_command_part(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[10][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(75, 'command_part'));
  var subtree;
  var t;
  ctx.nonterminal = "command_part";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 34) { // $command_part = :cmd_part
    ctx.rule = rules[34];
    tree.astTransform = new AstTransformSubstitution(0);
    t = expect(ctx, 0); // :cmd_part
    tree.add(t);
    return tree;
  } else if (rule == 35) { // $command_part = $expression_placeholder
    ctx.rule = rules[35];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_expression_placeholder(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[75],
    rules[35]
  ));
}
function parse_declaration(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[69][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(134, 'declaration'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "declaration";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 53) { // $declaration = $type_e :identifier $setter -> Declaration( type=$0, name=$1, expression=$2 )
    ctx.rule = rules[53];
    ast_parameters = {
      'type': 0,
      'name': 1,
      'expression': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Declaration', ast_parameters);
    subtree = parse_type_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    subtree = parse_setter(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[134],
    rules[53]
  ));
}
function parse_document(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[5][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(70, 'document'));
  var ast_parameters;
  var subtree;
  ctx.nonterminal = "document";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 2) { // $document = $version $_gen0 $_gen1 -> Draft3File( version=$0, imports=$1, body=$2 )
    ctx.rule = rules[2];
    ast_parameters = {
      'version': 0,
      'imports': 1,
      'body': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Draft3File', ast_parameters);
    subtree = parse_version(ctx);
    tree.add(subtree);
    subtree = parse__gen0(ctx);
    tree.add(subtree);
    subtree = parse__gen1(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[70],
    rules[2]
  ));
}
function parse_expression_placeholder(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[14][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(79, 'expression_placeholder'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "expression_placeholder";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 37) { // $expression_placeholder = :expression_placeholder_start $_gen9 $e :expression_placeholder_end -> ExpressionPlaceholder( attributes=$1, expr=$2 )
    ctx.rule = rules[37];
    ast_parameters = {
      'attributes': 1,
      'expr': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('ExpressionPlaceholder', ast_parameters);
    t = expect(ctx, 8); // :expression_placeholder_start
    tree.add(t);
    subtree = parse__gen9(ctx);
    tree.add(subtree);
    subtree = parse_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 55); // :expression_placeholder_end
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[79],
    rules[37]
  ));
}
function parse_expression_placeholder_kv(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[59][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(124, 'expression_placeholder_kv'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "expression_placeholder_kv";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 38) { // $expression_placeholder_kv = :cmd_attr_hint :identifier :equal $e -> ExpressionPlaceholderAttr( key=$1, value=$3 )
    ctx.rule = rules[38];
    ast_parameters = {
      'key': 1,
      'value': 3,
    }
    tree.astTransform = new AstTransformNodeCreator('ExpressionPlaceholderAttr', ast_parameters);
    t = expect(ctx, 60); // :cmd_attr_hint
    tree.add(t);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    t = expect(ctx, 46); // :equal
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[124],
    rules[38]
  ));
}
function parse_file_body_element(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[66][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(131, 'file_body_element'));
  var subtree;
  ctx.nonterminal = "file_body_element";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 3) { // $file_body_element = $workflow
    ctx.rule = rules[3];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_workflow(ctx);
    tree.add(subtree);
    return tree;
  } else if (rule == 4) { // $file_body_element = $task
    ctx.rule = rules[4];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_task(ctx);
    tree.add(subtree);
    return tree;
  } else if (rule == 5) { // $file_body_element = $struct
    ctx.rule = rules[5];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_struct(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[131],
    rules[5]
  ));
}
function parse_if_stmt(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[65][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(130, 'if_stmt'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "if_stmt";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 84) { // $if_stmt = :if :lparen $e :rparen :lbrace $_gen15 :rbrace -> If( expression=$2, body=$5 )
    ctx.rule = rules[84];
    ast_parameters = {
      'expression': 2,
      'body': 5,
    }
    tree.astTransform = new AstTransformNodeCreator('If', ast_parameters);
    t = expect(ctx, 48); // :if
    tree.add(t);
    t = expect(ctx, 51); // :lparen
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 1); // :rparen
    tree.add(t);
    t = expect(ctx, 34); // :lbrace
    tree.add(t);
    subtree = parse__gen15(ctx);
    tree.add(subtree);
    t = expect(ctx, 62); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[130],
    rules[84]
  ));
}
function parse_import(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[24][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(89, 'import'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "import";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 20) { // $import = :import $static_string $_gen5 $_gen6 -> Import( uri=$1, namespace=$2, aliases=$3 )
    ctx.rule = rules[20];
    ast_parameters = {
      'uri': 1,
      'namespace': 2,
      'aliases': 3,
    }
    tree.astTransform = new AstTransformNodeCreator('Import', ast_parameters);
    t = expect(ctx, 30); // :import
    tree.add(t);
    subtree = parse_static_string(ctx);
    tree.add(subtree);
    subtree = parse__gen5(ctx);
    tree.add(subtree);
    subtree = parse__gen6(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[89],
    rules[20]
  ));
}
function parse_import_alias(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[26][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(91, 'import_alias'));
  var ast_parameters;
  var t;
  ctx.nonterminal = "import_alias";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 22) { // $import_alias = :alias :identifier :as :identifier -> ImportAlias( old_name=$1, new_name=$3 )
    ctx.rule = rules[22];
    ast_parameters = {
      'old_name': 1,
      'new_name': 3,
    }
    tree.astTransform = new AstTransformNodeCreator('ImportAlias', ast_parameters);
    t = expect(ctx, 63); // :alias
    tree.add(t);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    t = expect(ctx, 59); // :as
    tree.add(t);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[91],
    rules[22]
  ));
}
function parse_import_namespace(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[4][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(69, 'import_namespace'));
  var t;
  ctx.nonterminal = "import_namespace";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 21) { // $import_namespace = :as :identifier -> $1
    ctx.rule = rules[21];
    tree.astTransform = new AstTransformSubstitution(1);
    t = expect(ctx, 59); // :as
    tree.add(t);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[69],
    rules[21]
  ));
}
function parse_input_declaration(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[13][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(78, 'input_declaration'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "input_declaration";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 52) { // $input_declaration = $type_e :identifier $_gen13 -> InputDeclaration( type=$0, name=$1, expression=$2 )
    ctx.rule = rules[52];
    ast_parameters = {
      'type': 0,
      'name': 1,
      'expression': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('InputDeclaration', ast_parameters);
    subtree = parse_type_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    subtree = parse__gen13(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[78],
    rules[52]
  ));
}
function parse_input_kv(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[61][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(126, 'input_kv'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "input_kv";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 87) { // $input_kv = :identifier :equal $e -> ObjectKV( key=$0, value=$2 )
    ctx.rule = rules[87];
    ast_parameters = {
      'key': 0,
      'value': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('ObjectKV', ast_parameters);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    t = expect(ctx, 46); // :equal
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[126],
    rules[87]
  ));
}
function parse_inputs(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[8][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(73, 'inputs'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "inputs";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 40) { // $inputs = :input :lbrace $_gen10 :rbrace -> Inputs( inputs=$2 )
    ctx.rule = rules[40];
    ast_parameters = {
      'inputs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Inputs', ast_parameters);
    t = expect(ctx, 42); // :input
    tree.add(t);
    t = expect(ctx, 34); // :lbrace
    tree.add(t);
    subtree = parse__gen10(ctx);
    tree.add(subtree);
    t = expect(ctx, 62); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[73],
    rules[40]
  ));
}
function parse_kv(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[60][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(125, 'kv'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "kv";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 44) { // $kv = :identifier :colon $e -> RuntimeAttribute( key=$0, value=$2 )
    ctx.rule = rules[44];
    ast_parameters = {
      'key': 0,
      'value': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('RuntimeAttribute', ast_parameters);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    t = expect(ctx, 27); // :colon
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[125],
    rules[44]
  ));
}
function parse_map_kv(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[36][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(101, 'map_kv'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "map_kv";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 55) { // $map_kv = $e :colon $e -> MapLiteralKv( key=$0, value=$2 )
    ctx.rule = rules[55];
    ast_parameters = {
      'key': 0,
      'value': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('MapLiteralKv', ast_parameters);
    subtree = parse_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 27); // :colon
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[101],
    rules[55]
  ));
}
function parse_meta(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[70][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(135, 'meta'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "meta";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 45) { // $meta = :meta $meta_map -> Meta( map=$1 )
    ctx.rule = rules[45];
    ast_parameters = {
      'map': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('Meta', ast_parameters);
    t = expect(ctx, 4); // :meta
    tree.add(t);
    subtree = parse_meta_map(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[135],
    rules[45]
  ));
}
function parse_meta_kv(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[57][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(122, 'meta_kv'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "meta_kv";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 49) { // $meta_kv = :identifier :colon $meta_value -> MetaKvPair( key=$0, value=$2 )
    ctx.rule = rules[49];
    ast_parameters = {
      'key': 0,
      'value': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('MetaKvPair', ast_parameters);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    t = expect(ctx, 27); // :colon
    tree.add(t);
    subtree = parse_meta_value(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[122],
    rules[49]
  ));
}
function parse_meta_map(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[35][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(100, 'meta_map'));
  var subtree;
  var t;
  ctx.nonterminal = "meta_map";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 48) { // $meta_map = :lbrace $_gen12 :rbrace -> $1
    ctx.rule = rules[48];
    tree.astTransform = new AstTransformSubstitution(1);
    t = expect(ctx, 34); // :lbrace
    tree.add(t);
    subtree = parse__gen12(ctx);
    tree.add(subtree);
    t = expect(ctx, 62); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[100],
    rules[48]
  ));
}
function parse_object_kv(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[27][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(92, 'object_kv'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "object_kv";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 86) { // $object_kv = :identifier :colon $e -> ObjectKV( key=$0, value=$2 )
    ctx.rule = rules[86];
    ast_parameters = {
      'key': 0,
      'value': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('ObjectKV', ast_parameters);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    t = expect(ctx, 27); // :colon
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[92],
    rules[86]
  ));
}
function parse_output_kv(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[18][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(83, 'output_kv'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "output_kv";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 58) { // $output_kv = $type_e :identifier :equal $e -> Output( type=$0, name=$1, expression=$3 )
    ctx.rule = rules[58];
    ast_parameters = {
      'type': 0,
      'name': 1,
      'expression': 3,
    }
    tree.astTransform = new AstTransformNodeCreator('Output', ast_parameters);
    subtree = parse_type_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    t = expect(ctx, 46); // :equal
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[83],
    rules[58]
  ));
}
function parse_outputs(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[19][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(84, 'outputs'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "outputs";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 57) { // $outputs = :output :lbrace $_gen14 :rbrace -> Outputs( outputs=$2 )
    ctx.rule = rules[57];
    ast_parameters = {
      'outputs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Outputs', ast_parameters);
    t = expect(ctx, 11); // :output
    tree.add(t);
    t = expect(ctx, 34); // :lbrace
    tree.add(t);
    subtree = parse__gen14(ctx);
    tree.add(subtree);
    t = expect(ctx, 62); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[84],
    rules[57]
  ));
}
function parse_parameter_meta(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[34][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(99, 'parameter_meta'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "parameter_meta";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 46) { // $parameter_meta = :parameter_meta $meta_map -> ParameterMeta( map=$1 )
    ctx.rule = rules[46];
    ast_parameters = {
      'map': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('ParameterMeta', ast_parameters);
    t = expect(ctx, 22); // :parameter_meta
    tree.add(t);
    subtree = parse_meta_map(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[99],
    rules[46]
  ));
}
function parse_rt_map(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[58][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(123, 'rt_map'));
  var subtree;
  var t;
  ctx.nonterminal = "rt_map";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 43) { // $rt_map = :lbrace $_gen11 :rbrace -> $1
    ctx.rule = rules[43];
    tree.astTransform = new AstTransformSubstitution(1);
    t = expect(ctx, 34); // :lbrace
    tree.add(t);
    subtree = parse__gen11(ctx);
    tree.add(subtree);
    t = expect(ctx, 62); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[123],
    rules[43]
  ));
}
function parse_runtime(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[9][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(74, 'runtime'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "runtime";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 41) { // $runtime = :runtime $rt_map -> Runtime( map=$1 )
    ctx.rule = rules[41];
    ast_parameters = {
      'map': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('Runtime', ast_parameters);
    t = expect(ctx, 49); // :runtime
    tree.add(t);
    subtree = parse_rt_map(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[74],
    rules[41]
  ));
}
function parse_scatter(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[55][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(120, 'scatter'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "scatter";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 85) { // $scatter = :scatter :lparen :identifier :in $e :rparen :lbrace $_gen15 :rbrace -> Scatter( item=$2, collection=$4, body=$7 )
    ctx.rule = rules[85];
    ast_parameters = {
      'item': 2,
      'collection': 4,
      'body': 7,
    }
    tree.astTransform = new AstTransformNodeCreator('Scatter', ast_parameters);
    t = expect(ctx, 35); // :scatter
    tree.add(t);
    t = expect(ctx, 51); // :lparen
    tree.add(t);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    t = expect(ctx, 18); // :in
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 1); // :rparen
    tree.add(t);
    t = expect(ctx, 34); // :lbrace
    tree.add(t);
    subtree = parse__gen15(ctx);
    tree.add(subtree);
    t = expect(ctx, 62); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[120],
    rules[85]
  ));
}
function parse_setter(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[2][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(67, 'setter'));
  var subtree;
  var t;
  ctx.nonterminal = "setter";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 54) { // $setter = :equal $e -> $1
    ctx.rule = rules[54];
    tree.astTransform = new AstTransformSubstitution(1);
    t = expect(ctx, 46); // :equal
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[67],
    rules[54]
  ));
}
function parse_static_string(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[16][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(81, 'static_string'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "static_string";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 12) { // $static_string = :quote $_gen3 :quote -> StaticString( value=$1 )
    ctx.rule = rules[12];
    ast_parameters = {
      'value': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('StaticString', ast_parameters);
    t = expect(ctx, 21); // :quote
    tree.add(t);
    subtree = parse__gen3(ctx);
    tree.add(subtree);
    t = expect(ctx, 21); // :quote
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[81],
    rules[12]
  ));
}
function parse_string_literal(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[17][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(82, 'string_literal'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "string_literal";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 14) { // $string_literal = :quote $_gen4 :quote -> StringLiteral( pieces=$1 )
    ctx.rule = rules[14];
    ast_parameters = {
      'pieces': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('StringLiteral', ast_parameters);
    t = expect(ctx, 21); // :quote
    tree.add(t);
    subtree = parse__gen4(ctx);
    tree.add(subtree);
    t = expect(ctx, 21); // :quote
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[82],
    rules[14]
  ));
}
function parse_string_piece(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[32][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(97, 'string_piece'));
  var subtree;
  var t;
  ctx.nonterminal = "string_piece";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 15) { // $string_piece = :string
    ctx.rule = rules[15];
    tree.astTransform = new AstTransformSubstitution(0);
    t = expect(ctx, 47); // :string
    tree.add(t);
    return tree;
  } else if (rule == 16) { // $string_piece = $expression_placeholder
    ctx.rule = rules[16];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_expression_placeholder(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[97],
    rules[16]
  ));
}
function parse_struct(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[56][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(121, 'struct'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "struct";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 8) { // $struct = :struct :identifier :lbrace $_gen2 :rbrace -> Struct( name=$1, entries=$3 )
    ctx.rule = rules[8];
    ast_parameters = {
      'name': 1,
      'entries': 3,
    }
    tree.astTransform = new AstTransformNodeCreator('Struct', ast_parameters);
    t = expect(ctx, 5); // :struct
    tree.add(t);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    t = expect(ctx, 34); // :lbrace
    tree.add(t);
    subtree = parse__gen2(ctx);
    tree.add(subtree);
    t = expect(ctx, 62); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[121],
    rules[8]
  ));
}
function parse_struct_declaration(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[15][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(80, 'struct_declaration'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "struct_declaration";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 9) { // $struct_declaration = $type_e :identifier -> StructEntry( type=$0, name=$1 )
    ctx.rule = rules[9];
    ast_parameters = {
      'type': 0,
      'name': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('StructEntry', ast_parameters);
    subtree = parse_type_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[80],
    rules[9]
  ));
}
function parse_task(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[71][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(136, 'task'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "task";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 24) { // $task = :task :identifier :lbrace $_gen7 :rbrace -> Task( name=$1, sections=$3 )
    ctx.rule = rules[24];
    ast_parameters = {
      'name': 1,
      'sections': 3,
    }
    tree.astTransform = new AstTransformNodeCreator('Task', ast_parameters);
    t = expect(ctx, 40); // :task
    tree.add(t);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    t = expect(ctx, 34); // :lbrace
    tree.add(t);
    subtree = parse__gen7(ctx);
    tree.add(subtree);
    t = expect(ctx, 62); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[136],
    rules[24]
  ));
}
function parse_task_sections(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[33][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(98, 'task_sections'));
  var subtree;
  ctx.nonterminal = "task_sections";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 25) { // $task_sections = $command
    ctx.rule = rules[25];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_command(ctx);
    tree.add(subtree);
    return tree;
  } else if (rule == 26) { // $task_sections = $inputs
    ctx.rule = rules[26];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_inputs(ctx);
    tree.add(subtree);
    return tree;
  } else if (rule == 27) { // $task_sections = $outputs
    ctx.rule = rules[27];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_outputs(ctx);
    tree.add(subtree);
    return tree;
  } else if (rule == 28) { // $task_sections = $runtime
    ctx.rule = rules[28];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_runtime(ctx);
    tree.add(subtree);
    return tree;
  } else if (rule == 29) { // $task_sections = $parameter_meta
    ctx.rule = rules[29];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_parameter_meta(ctx);
    tree.add(subtree);
    return tree;
  } else if (rule == 30) { // $task_sections = $meta
    ctx.rule = rules[30];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_meta(ctx);
    tree.add(subtree);
    return tree;
  } else if (rule == 31) { // $task_sections = $declaration
    ctx.rule = rules[31];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_declaration(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[98],
    rules[31]
  ));
}
function parse_version(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[45][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(110, 'version'));
  var ast_parameters;
  var t;
  ctx.nonterminal = "version";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 6) { // $version = :version :version_name -> VersionDeclaration( v=$1 )
    ctx.rule = rules[6];
    ast_parameters = {
      'v': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('VersionDeclaration', ast_parameters);
    t = expect(ctx, 45); // :version
    tree.add(t);
    t = expect(ctx, 23); // :version_name
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[110],
    rules[6]
  ));
}
function parse_wf_body_element(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[48][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(113, 'wf_body_element'));
  var subtree;
  ctx.nonterminal = "wf_body_element";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 61) { // $wf_body_element = $call
    ctx.rule = rules[61];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_call(ctx);
    tree.add(subtree);
    return tree;
  } else if (rule == 62) { // $wf_body_element = $declaration
    ctx.rule = rules[62];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_declaration(ctx);
    tree.add(subtree);
    return tree;
  } else if (rule == 63) { // $wf_body_element = $while_loop
    ctx.rule = rules[63];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_while_loop(ctx);
    tree.add(subtree);
    return tree;
  } else if (rule == 64) { // $wf_body_element = $if_stmt
    ctx.rule = rules[64];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_if_stmt(ctx);
    tree.add(subtree);
    return tree;
  } else if (rule == 65) { // $wf_body_element = $scatter
    ctx.rule = rules[65];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_scatter(ctx);
    tree.add(subtree);
    return tree;
  } else if (rule == 66) { // $wf_body_element = $inputs
    ctx.rule = rules[66];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_inputs(ctx);
    tree.add(subtree);
    return tree;
  } else if (rule == 67) { // $wf_body_element = $outputs
    ctx.rule = rules[67];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_outputs(ctx);
    tree.add(subtree);
    return tree;
  } else if (rule == 68) { // $wf_body_element = $wf_parameter_meta
    ctx.rule = rules[68];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_wf_parameter_meta(ctx);
    tree.add(subtree);
    return tree;
  } else if (rule == 69) { // $wf_body_element = $wf_meta
    ctx.rule = rules[69];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_wf_meta(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[113],
    rules[69]
  ));
}
function parse_wf_meta(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[40][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(105, 'wf_meta'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "wf_meta";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 82) { // $wf_meta = :meta $meta_map -> Meta( map=$1 )
    ctx.rule = rules[82];
    ast_parameters = {
      'map': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('Meta', ast_parameters);
    t = expect(ctx, 4); // :meta
    tree.add(t);
    subtree = parse_meta_map(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[105],
    rules[82]
  ));
}
function parse_wf_parameter_meta(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[44][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(109, 'wf_parameter_meta'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "wf_parameter_meta";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 81) { // $wf_parameter_meta = :parameter_meta $meta_map -> ParameterMeta( map=$1 )
    ctx.rule = rules[81];
    ast_parameters = {
      'map': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('ParameterMeta', ast_parameters);
    t = expect(ctx, 22); // :parameter_meta
    tree.add(t);
    subtree = parse_meta_map(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[109],
    rules[81]
  ));
}
function parse_while_loop(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[63][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(128, 'while_loop'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "while_loop";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 83) { // $while_loop = :while :lparen $e :rparen :lbrace $_gen15 :rbrace -> WhileLoop( expression=$2, body=$5 )
    ctx.rule = rules[83];
    ast_parameters = {
      'expression': 2,
      'body': 5,
    }
    tree.astTransform = new AstTransformNodeCreator('WhileLoop', ast_parameters);
    t = expect(ctx, 50); // :while
    tree.add(t);
    t = expect(ctx, 51); // :lparen
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 1); // :rparen
    tree.add(t);
    t = expect(ctx, 34); // :lbrace
    tree.add(t);
    subtree = parse__gen15(ctx);
    tree.add(subtree);
    t = expect(ctx, 62); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[128],
    rules[83]
  ));
}
function parse_workflow(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[31][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(96, 'workflow'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "workflow";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 60) { // $workflow = :workflow :identifier :lbrace $_gen15 :rbrace -> Workflow( name=$1, body=$3 )
    ctx.rule = rules[60];
    ast_parameters = {
      'name': 1,
      'body': 3,
    }
    tree.astTransform = new AstTransformNodeCreator('Workflow', ast_parameters);
    t = expect(ctx, 36); // :workflow
    tree.add(t);
    t = expect(ctx, 37); // :identifier
    tree.add(t);
    t = expect(ctx, 34); // :lbrace
    tree.add(t);
    subtree = parse__gen15(ctx);
    tree.add(subtree);
    t = expect(ctx, 62); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[96],
    rules[60]
  ));
}
// Section: Lexer
// START USER CODE
function init() {
  return {wf_or_task: null};
}
function workflow(ctx, terminal, source_string, line, col) {
  ctx.user_context.wf_or_task = "workflow";
  default_action(ctx, terminal, source_string, line, col);
}
function task(ctx, terminal, source_string, line, col) {
  ctx.user_context.wf_or_task = "task";
  default_action(ctx, terminal, source_string, line, col);
}
function output(ctx, terminal, source_string, line, col) {
  const user_ctx = ctx.user_context;
  if (user_ctx.wf_or_task != null && user_ctx.wf_or_task === "workflow") {
    ctx.mode_stack.push("wf_output");
  }
  default_action(ctx, terminal, source_string, line, col);
}
function wdl_unescape(ctx, terminal, source_string, line, col) {
  var strip_slashes = function(str) {
    return str
      .replace(/\\(.?)/g, function(s, n1) {
        var escapes = {
          '\\': '\\',
          '0': '\u0000',
          '': '',
          'n': '\n',
          'r': '\r',
          'b': '\b',
          't': '\t',
          'f': '\f',
          'a': '\a',
          'v': '\v'
        };
        var symbol = escapes[n1];
        if (symbol !== undefined) {
          return symbol;
        }
        return n1;
      });
  }
  var repl_str = strip_slashes(source_string);
  default_action(ctx, terminal, repl_str, line, col);
}
// END USER CODE
function emit(ctx, terminal, source_string, line, col) {
  ctx.tokens.push(new Terminal(terminals[terminal], terminal, source_string, ctx.resource, line, col))
}
function default_action(ctx, terminal, source_string, line, col) {
  emit(ctx, terminal, source_string, line, col)
}
function destroy(context) {
  return 0;
}
var regex = {
  'default': [
    {
      regex: new RegExp("#.*"),
      outputs: []
    },
    {
      regex: new RegExp("\\s+"),
      outputs: []
    },
    {
      regex: new RegExp("^version(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'version',
          group: 0,
          function: null,
        },
        {
          stack_push: 'awaiting_version_name',
        },
      ]
    },
  ],
  'main': [
    {
      regex: new RegExp("\\s+"),
      outputs: []
    },
    {
      regex: new RegExp("/\\*(.*?)\\*/", "m"),
      outputs: []
    },
    {
      regex: new RegExp("#.*"),
      outputs: []
    },
    {
      regex: new RegExp("task(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'task',
          group: 0,
          function: task,
        },
      ]
    },
    {
      regex: new RegExp("(call)\\s+"),
      outputs: [
        {
          terminal: 'call',
          group: 1,
          function: null,
        },
        {
          stack_push: 'task_fqn',
        },
      ]
    },
    {
      regex: new RegExp("workflow(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'workflow',
          group: 0,
          function: workflow,
        },
      ]
    },
    {
      regex: new RegExp("struct(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'struct',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("import(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'import',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("alias(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'alias',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("input(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'input',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("output(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'output',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("as(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'as',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("if(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'if',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("then(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'then',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("else(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'else',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("runtime(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'runtime',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("scatter(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'scatter',
          group: 0,
          function: null,
        },
        {
          stack_push: 'scatter',
        },
      ]
    },
    {
      regex: new RegExp("command\\s*(?=<<<)"),
      outputs: [
        {
          terminal: 'raw_command',
          group: 0,
          function: null,
        },
        {
          stack_push: 'raw_command2',
        },
      ]
    },
    {
      regex: new RegExp("command\\s*(?=\\{)"),
      outputs: [
        {
          terminal: 'raw_command',
          group: 0,
          function: null,
        },
        {
          stack_push: 'raw_command',
        },
      ]
    },
    {
      regex: new RegExp("parameter_meta(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'parameter_meta',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("meta(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'meta',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("(true|false)(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'boolean',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("(object)\\s*(\\{)"),
      outputs: [
        {
          terminal: 'object',
          group: 0,
          function: null,
        },
        {
          terminal: 'lbrace',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("(Array|Map|Object|Pair|Boolean|Int|Float|Uri|File|String)(?![a-zA-Z0-9_])(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'type',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*"),
      outputs: [
        {
          terminal: 'identifier',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("null"),
      outputs: [
        {
          terminal: 'null',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(":"),
      outputs: [
        {
          terminal: 'colon',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(","),
      outputs: [
        {
          terminal: 'comma',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("=="),
      outputs: [
        {
          terminal: 'double_equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\|\\|"),
      outputs: [
        {
          terminal: 'double_pipe',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\&\\&"),
      outputs: [
        {
          terminal: 'double_ampersand',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("!="),
      outputs: [
        {
          terminal: 'not_equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("="),
      outputs: [
        {
          terminal: 'equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\."),
      outputs: [
        {
          terminal: 'dot',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\{"),
      outputs: [
        {
          terminal: 'lbrace',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\}"),
      outputs: [
        {
          terminal: 'rbrace',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\("),
      outputs: [
        {
          terminal: 'lparen',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\)"),
      outputs: [
        {
          terminal: 'rparen',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\["),
      outputs: [
        {
          terminal: 'lsquare',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\]"),
      outputs: [
        {
          terminal: 'rsquare',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\+"),
      outputs: [
        {
          terminal: 'plus',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\*"),
      outputs: [
        {
          terminal: 'asterisk',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("-"),
      outputs: [
        {
          terminal: 'dash',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("/"),
      outputs: [
        {
          terminal: 'slash',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("%"),
      outputs: [
        {
          terminal: 'percent',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("<="),
      outputs: [
        {
          terminal: 'lteq',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("<"),
      outputs: [
        {
          terminal: 'lt',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(">="),
      outputs: [
        {
          terminal: 'gteq',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(">"),
      outputs: [
        {
          terminal: 'gt',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("!"),
      outputs: [
        {
          terminal: 'not',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\""),
      outputs: [
        {
          terminal: 'quote',
          group: 0,
          function: null,
        },
        {
          stack_push: 'dquote_string',
        },
      ]
    },
    {
      regex: new RegExp("\\'"),
      outputs: [
        {
          terminal: 'quote',
          group: 0,
          function: null,
        },
        {
          stack_push: 'squote_string',
        },
      ]
    },
    {
      regex: new RegExp("\\?"),
      outputs: [
        {
          terminal: 'qmark',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("-?[0-9]+\\.[0-9]+"),
      outputs: [
        {
          terminal: 'float',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("[0-9]+"),
      outputs: [
        {
          terminal: 'integer',
          group: 0,
          function: null,
        },
      ]
    },
  ],
  'dquote_string': [
    {
      regex: new RegExp("\""),
      outputs: [
        {
          terminal: 'quote',
          group: 0,
          function: null,
        },
        {
          action: 'pop',
        },
      ]
    },
    {
      regex: new RegExp("\\$\\{"),
      outputs: [
        {
          terminal: 'expression_placeholder_start',
          group: 0,
          function: null,
        },
        {
          stack_push: 'expression_placeholder',
        },
      ]
    },
    {
      regex: new RegExp("~\\{"),
      outputs: [
        {
          terminal: 'expression_placeholder_start',
          group: 0,
          function: null,
        },
        {
          stack_push: 'expression_placeholder',
        },
      ]
    },
    {
      regex: new RegExp("[^\"\\n(${)(~{)]*"),
      outputs: [
        {
          terminal: 'string',
          group: 0,
          function: wdl_unescape,
        },
      ]
    },
  ],
  'squote_string': [
    {
      regex: new RegExp("\\'"),
      outputs: [
        {
          terminal: 'quote',
          group: 0,
          function: null,
        },
        {
          action: 'pop',
        },
      ]
    },
    {
      regex: new RegExp("\\$\\{"),
      outputs: [
        {
          terminal: 'expression_placeholder_start',
          group: 0,
          function: null,
        },
        {
          stack_push: 'expression_placeholder',
        },
      ]
    },
    {
      regex: new RegExp("~\\{"),
      outputs: [
        {
          terminal: 'expression_placeholder_start',
          group: 0,
          function: null,
        },
        {
          stack_push: 'expression_placeholder',
        },
      ]
    },
    {
      regex: new RegExp("[^'\\n(${)(~{)]*"),
      outputs: [
        {
          terminal: 'string',
          group: 0,
          function: wdl_unescape,
        },
      ]
    },
  ],
  'awaiting_version_name': [
    {
      regex: new RegExp("\\s+"),
      outputs: []
    },
    {
      regex: new RegExp("1.0"),
      outputs: [
        {
          terminal: 'version_name',
          group: 0,
          function: null,
        },
        {
          stack_push: 'main',
        },
      ]
    },
  ],
  'task_fqn': [
    {
      regex: new RegExp("\\s+"),
      outputs: []
    },
    {
      regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*(\\.[a-zA-Z]([a-zA-Z0-9_])*)*"),
      outputs: [
        {
          terminal: 'fqn',
          group: 0,
          function: null,
        },
        {
          action: 'pop',
        },
      ]
    },
  ],
  'scatter': [
    {
      regex: new RegExp("\\s+"),
      outputs: []
    },
    {
      regex: new RegExp("\\("),
      outputs: [
        {
          terminal: 'lparen',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("in(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'in',
          group: 0,
          function: null,
        },
        {
          action: 'pop',
        },
      ]
    },
    {
      regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*"),
      outputs: [
        {
          terminal: 'identifier',
          group: 0,
          function: null,
        },
      ]
    },
  ],
  'raw_command': [
    {
      regex: new RegExp("\\{"),
      outputs: [
        {
          terminal: 'raw_cmd_start',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\}"),
      outputs: [
        {
          terminal: 'raw_cmd_end',
          group: 0,
          function: null,
        },
        {
          action: 'pop',
        },
      ]
    },
    {
      regex: new RegExp("\\$\\{"),
      outputs: [
        {
          terminal: 'expression_placeholder_start',
          group: 0,
          function: null,
        },
        {
          stack_push: 'expression_placeholder',
        },
      ]
    },
    {
      regex: new RegExp("~\\{"),
      outputs: [
        {
          terminal: 'expression_placeholder_start',
          group: 0,
          function: null,
        },
        {
          stack_push: 'expression_placeholder',
        },
      ]
    },
    {
      regex: new RegExp("([\\s\\S]*?)(?=\\$\\{|~\\{|\\})", "m"),
      outputs: [
        {
          terminal: 'cmd_part',
          group: 0,
          function: null,
        },
      ]
    },
  ],
  'raw_command2': [
    {
      regex: new RegExp("<<<"),
      outputs: [
        {
          terminal: 'raw_cmd_start',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(">>>"),
      outputs: [
        {
          terminal: 'raw_cmd_end',
          group: 0,
          function: null,
        },
        {
          action: 'pop',
        },
      ]
    },
    {
      regex: new RegExp("~\\{"),
      outputs: [
        {
          terminal: 'expression_placeholder_start',
          group: 0,
          function: null,
        },
        {
          stack_push: 'expression_placeholder',
        },
      ]
    },
    {
      regex: new RegExp("([\\s\\S]*?)(?=~\\{|>>>)", "m"),
      outputs: [
        {
          terminal: 'cmd_part',
          group: 0,
          function: null,
        },
      ]
    },
  ],
  'expression_placeholder': [
    {
      regex: new RegExp("\\s+"),
      outputs: []
    },
    {
      regex: new RegExp("\\}"),
      outputs: [
        {
          terminal: 'expression_placeholder_end',
          group: 0,
          function: null,
        },
        {
          action: 'pop',
        },
      ]
    },
    {
      regex: new RegExp("\\["),
      outputs: [
        {
          terminal: 'lsquare',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\]"),
      outputs: [
        {
          terminal: 'rsquare',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("="),
      outputs: [
        {
          terminal: 'equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\+"),
      outputs: [
        {
          terminal: 'plus',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\*"),
      outputs: [
        {
          terminal: 'asterisk',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("[0-9]+"),
      outputs: [
        {
          terminal: 'integer',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("if"),
      outputs: [
        {
          terminal: 'if',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("else"),
      outputs: [
        {
          terminal: 'else',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("then"),
      outputs: [
        {
          terminal: 'then',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*(?=\\s*=)"),
      outputs: [
        {
          terminal: 'cmd_attr_hint',
          group: null,
          function: null,
        },
        {
          terminal: 'identifier',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("(true|false)(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'boolean',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("(Array|Map|Object|Pair|Boolean|Int|Float|Uri|File|String)(?![a-zA-Z0-9_])(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'type',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*"),
      outputs: [
        {
          terminal: 'identifier',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(":"),
      outputs: [
        {
          terminal: 'colon',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(","),
      outputs: [
        {
          terminal: 'comma',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\."),
      outputs: [
        {
          terminal: 'dot',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("=="),
      outputs: [
        {
          terminal: 'double_equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\|\\|"),
      outputs: [
        {
          terminal: 'double_pipe',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\&\\&"),
      outputs: [
        {
          terminal: 'double_ampersand',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("!="),
      outputs: [
        {
          terminal: 'not_equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("="),
      outputs: [
        {
          terminal: 'equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\."),
      outputs: [
        {
          terminal: 'dot',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\{"),
      outputs: [
        {
          terminal: 'lbrace',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\("),
      outputs: [
        {
          terminal: 'lparen',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\)"),
      outputs: [
        {
          terminal: 'rparen',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\["),
      outputs: [
        {
          terminal: 'lsquare',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\]"),
      outputs: [
        {
          terminal: 'rsquare',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\+"),
      outputs: [
        {
          terminal: 'plus',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\*"),
      outputs: [
        {
          terminal: 'asterisk',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("-"),
      outputs: [
        {
          terminal: 'dash',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("/"),
      outputs: [
        {
          terminal: 'slash',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("%"),
      outputs: [
        {
          terminal: 'percent',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("<="),
      outputs: [
        {
          terminal: 'lteq',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("<"),
      outputs: [
        {
          terminal: 'lt',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(">="),
      outputs: [
        {
          terminal: 'gteq',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(">"),
      outputs: [
        {
          terminal: 'gt',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("!"),
      outputs: [
        {
          terminal: 'not',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\\\\\\""),
      outputs: [
        {
          terminal: 'quote',
          group: 0,
          function: null,
        },
        {
          stack_push: 'dquote_string',
        },
      ]
    },
    {
      regex: new RegExp("\\'"),
      outputs: [
        {
          terminal: 'quote',
          group: 0,
          function: null,
        },
        {
          stack_push: 'squote_string',
        },
      ]
    },
    {
      regex: new RegExp("-?[0-9]+\\.[0-9]+"),
      outputs: [
        {
          terminal: 'float',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("[0-9]+"),
      outputs: [
        {
          terminal: 'integer',
          group: 0,
          function: null,
        },
      ]
    },
  ],
}
function advance_line_col(string, length, line, col) {
  for (var i = 0; i < length; i++) {
    if (string[i] == '\n') {
      line += 1;
      col = 1;
    } else {
      col += 1;
    }
  }
  return {line: line, col: col}
}
function advance_string(ctx, string) {
  var lc = advance_line_col(string, string.length, ctx.line, ctx.col)
  ctx.line = lc.line
  ctx.col = lc.col
  ctx.string = ctx.string.substring(string.length)
}
function _unrecognized_token(string, line, col) {
  var lines = string.split('\n')
  var bad_line = lines[line - 1]
  var message = 'Unrecognized token on line {0}, column {1}:\n\n{2}\n{3}'.format(
    line, col, bad_line, Array(col).join(' ') + '^'
  )
  throw new SyntaxError(message)
}
function _next(ctx) {
  var tokens = []
  var mode = ctx.mode_stack[ctx.mode_stack.length - 1]
  for (var i = 0; i < regex[mode].length; i++) {
    var match = regex[mode][i].regex.exec(ctx.string);
    if (match != null && match.index == 0) {
      for (var j = 0; j < regex[mode][i].outputs.length; j++) {
        var terminal = regex[mode][i].outputs[j].terminal;
        var group = regex[mode][i].outputs[j].group;
        var func = regex[mode][i].outputs[j].function;
        var stack_push = regex[mode][i].outputs[j].stack_push;
        var action = regex[mode][i].outputs[j].action;
        if (stack_push !== undefined) {
          ctx.mode_stack.push(stack_push)
        } else if (action !== undefined) {
          if (action == 'pop') {
            ctx.mode_stack.pop()
          }
        } else {
          func = (func == null) ? default_action : func;
          var source_string = group != null ? match[group] : ""
          // Ugh!  JavaScript why you no have regex group indexes?!
          var group_line = ctx.line
          var group_col = ctx.col
          try {
            var mult_regex = new MultiRegExp(regex[mode][i].regex.source);
            var mult_groups = mult_regex.exec(ctx.string)
            if (group != null && group > 0) {
              var lc = advance_line_col(match[0], mult_groups[group - 1].index, ctx.line, ctx.col)
              group_line = lc.line
              group_col = lc.col
            }
          } catch (err) {}
          // ^ Literally the worst thing ever
          func(ctx, terminal, source_string, group_line, group_col)
        }
      }
      advance_string(ctx, match[0])
      return true
    }
  }
  return false
}
function lex(string, resource) {
  var ctx = {
    string: string,
    resource: resource,
    user_context: init(),
    mode_stack: ['default'],
    tokens: [],
    line: 1,
    col: 1
  }
  var string_copy = string
  var parsed_tokens = []
  while (ctx.string.length) {
    var matched = _next(ctx)
    if (matched == false) {
      _unrecognized_token(string_copy, ctx.line, ctx.col)
    }
  }
  destroy(ctx.user_context)
  return new TokenStream(ctx.tokens)
}
// Section: Main
// Section: Exports
module.exports = {
  lex: lex,
  parse: parse,
  terminals: terminals,
  parse_tree_string: parse_tree_string,
  ast_string: ast_string
}
