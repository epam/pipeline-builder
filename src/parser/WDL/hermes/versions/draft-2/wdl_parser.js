/* eslint-disable */
/*
 * This file was generated by Hermes Parser Generator on Wed May 10 16:02:35 2017
 *
 * Hermes command: hermes generate ./grammar.hgr --language=javascript --name=wdl1 --nodejs --header
 * Run from: . (relative to this file)
 * Hermes version: hermes-parser 2.0rc6
 *
 * !!! DO NOT CHANGE THIS FILE DIRECTLY !!!
 *
 * If you wish to change something in this file, either change the grammar and
 * re-generate this file, or change the templates in Hermes and regenerate.
 * See the Hermes repository: http://github.com/scottfrazer/hermes
 */
if (!String.prototype.format) {
  String.prototype.format = function() {
    var args = arguments;
    return this.replace(/{(\d+)}/g, function(match, number) {
      return typeof args[number] != 'undefined' ? args[number]: match;
    });
  };
}
String.prototype.lstrip = function() {
  return this.replace(/^\s*/g, "");
}
function parse_tree_string(parsetree, indent, b64_source) {
  return _parse_tree_string(parsetree, indent, b64_source, 0);
}
function _parse_tree_string(parsetree, indent, b64_source, indent_level) {
  if (typeof(indent) != 'number' || indent <= 0) {
    indent = undefined
  }
  var indent_str = typeof(indent) !== 'undefined' ? Array(indent * indent_level + 1).join(' ') : ''
  if (parsetree instanceof ParseTree) {
    var children = []
    for (var i in parsetree.children) {
      children.push(_parse_tree_string(parsetree.children[i], indent, b64_source, indent_level + 1))
    }
    if (typeof(indent) == 'undefined' || children.length == 0) {
      return '{0}({1}: {2})'.format(indent_str, parsetree.nonterminal.to_string(), children.join(', '))
    } else {
      return '{0}({1}:\n{2}\n{3})'.format(
        indent_str,
        parsetree.nonterminal.to_string(),
        children.join(',\n'),
        indent_str
      )
    }
  } else if (parsetree instanceof Terminal) {
    return indent_str + parsetree.to_string(b64_source)
  }
}
function ast_string(ast, indent, b64_source) {
  return _ast_string(ast, indent, b64_source, 0);
}
function _ast_string(ast, indent, b64_source, indent_level) {
  if (typeof(indent) != 'number' || indent <= 0) {
    indent = undefined
  }
  var indent_str = typeof(indent) !== 'undefined' ? Array(indent * indent_level + 1).join(' ') : ''
  var next_indent_str = typeof(indent) !== 'undefined' ? Array(indent * (indent_level+1) + 1).join(' ') : ''
  if (ast instanceof Ast) {
    var children = {}
    for (var key in ast.attributes) {
      children[key] = _ast_string(ast.attributes[key], indent, b64_source, indent_level + 1)
    }
    if (typeof(indent) == 'undefined') {
      var strs = []
      for (var key in children) {
        strs.push('{0}={1}'.format(key, children[key]))
      }
      return '({0}: {1})'.format(
        ast.name,
        strs.join(', ')
      )
    } else {
      var strs = []
      for (var key in children) {
        strs.push('{0}{1}={2}'.format(next_indent_str, key, children[key]))
      }
      return '({0}:\n{1}\n{2})'.format(
        ast.name,
        strs.join(',\n'),
        indent_str
      )
    }
  } else if (ast instanceof AstList) {
    var children = []
    for (var key in ast.list) {
      children.push(_ast_string(ast.list[key], indent, b64_source, indent_level + 1))
    }
    if (typeof(indent) == 'undefined' || children.length == 0) {
      return '[{0}]'.format(children.join(', '))
    } else {
      var strs = []
      for (var index in children) {
        strs.push('{0}{1}'.format(next_indent_str, children[index]))
      }
      return '[\n{0}\n{1}]'.format(
        strs.join(',\n'),
        indent_str
      )
    }
  } else if (ast instanceof Terminal) {
    return ast.to_string(b64_source)
  } else {
    return (ast == null) ? 'None' : ast.to_string()
  }
}
function Terminal(id, str, source_string, resource, line, col) {
  this.id = id;
  this.str = str;
  this.source_string = source_string;
  this.resource = resource;
  this.line = line;
  this.col = col;
  this.to_ast = function() {
    return this;
  };
  this.to_string = function(b64_source) {
    return '<{0}:{1}:{2} {3} "{4}">'.format(
      this.resource,
      this.line,
      this.col,
      this.str,
      b64_source ? Base64.encode(this.source_string) : this.source_string
    )
  };
}
function NonTerminal(id, str) {
  this.id = id;
  this.str = str;
  this.to_string = function() {
    return this.str;
  };
}
function AstTransformSubstitution(idx) {
  this.idx = idx;
  this.to_string = function() {
    return '$' + this.idx;
  };
}
function AstTransformNodeCreator(name, parameters) {
  this.name = name;
  this.parameters = parameters;
  this.to_string = function() {
    var arr = [];
    for ( key in this.parameters ) {
      arr.push('{0}=${1}'.format(key, this.parameters[key]));
    }
    return '{0} ( {1} )'.format(this.name, arr.join(', '));
  };
}
function AstList(list) {
  this.list = list
  this.push = function(element) {
    this.list.push(element);
  };
  this.to_ast = function() {
    var arr = [];
    for (item in this.list) {
      arr.push(item.to_ast());
    }
    return arr;
  };
}
function ParseTree(nonterminal) {
  this.children = [];
  this.nonterminal = nonterminal;
  this.astTransform = null;
  this.isExpr = false;
  this.isNud = false;
  this.isPrefix = false;
  this.isInfix = false;
  this.nudMorphemeCount = 0;
  this.isExprNud = false;
  this.listSeparator = null;
  this.list = false;
  this.add = function(tree) {
    this.children.push(tree);
  }
  this.to_ast = function() {
    var name;
    if (this.list == true) {
      if (this.children.length == 0) {
        return new AstList([]);
      }
      var end = this.children.length - 1;
      var list = [];
      for (var i = 0; i < this.children.length; i++) {
        if (this.children[i] instanceof Terminal && this.children[i].id == this.listSeparator)
          continue;
        list.push(this.children[i].to_ast());
      }
      return new AstList(list);
    }
    else if (this.isExpr == true) {
      if (this.astTransform instanceof AstTransformSubstitution) {
        return this.children[this.astTransform.idx].to_ast();
      }
      else if (this.astTransform instanceof AstTransformNodeCreator) {
        var parameters = {}
        for (name in this.astTransform.parameters) {
          var idx = this.astTransform.parameters[name];
          var child = null;
          if (idx == '$') {
            child = this.children[0];
          } else if (this.children[0] instanceof ParseTree && this.children[0].isNud && !this.children[0].isPrefix && !this.isExprNud && !this.isInfix) {
            if (idx < this.children[0].nudMorphemeCount) {
              child = this.children[0].children[idx]
            } else {
              var index = idx - this.children[0].nudMorphemeCount + 1
              child = this.children[index]
            }
          } else if (this.children.length == 1 && !(this.children[0] instanceof ParseTree) && !(this.children[0] instanceof Array)) {
            return this.children[0];
          } else {
            child = this.children[idx];
          }
          parameters[name] = child.to_ast()
        }
        return new Ast(this.astTransform.name, parameters);
      }
    }
    else {
      if (this.astTransform instanceof AstTransformSubstitution) {
        return this.children[this.astTransform.idx].to_ast()
      } else if (this.astTransform instanceof AstTransformNodeCreator) {
        var parameters = {};
        for (name in this.astTransform.parameters) {
          parameters[name] = this.children[this.astTransform.parameters[name]].to_ast();
        }
        return new Ast(this.astTransform.name, parameters);
        return x;
      } else if (this.children.length) {
        return this.children[0].to_ast();
      } else {
        return null;
      }
    }
  }
  this.to_string = function() {
    var children = []
    for (i in this.children) {
      var child = this.children[i];
      if (child instanceof Array) {
        var stringify = child.map(function(x) {return x.to_string()});
        children.push('[' + stringify.join(', ') + ']');
      } else {
        children.push(child.to_string());
      }
    }
    return '(' + this.nonterminal.to_string() + ': ' + children.join(', ') + ')'
  }
}
function Ast(name, attributes) {
  this.name = name;
  this.attributes = attributes;
  this.to_string = function() {
    var arr = [];
    for (var key in this.attributes) {
      var value = this.attributes[key];
      if (value instanceof Array) {
        var stringify = value.map(function(x) {return x.to_string()});
        value = '[{0}]'.format(stringify.join(', '));
      } else {
        value = value.to_string();
      }
      arr.push('{0}={1}'.format(key.to_string(), value))
    }
    return '({0}: {1})'.format(this.name, arr.join(', '));
  }
}
function SyntaxError(message) {
  this.name = 'SyntaxError';
  this.message = message;
  this.to_string = function() {
    return this.message;
  }
}
function TokenStream(list) {
  this.list = list;
  this.index = 0;
  this.advance = function() {
    this.index += 1;
    return this.current();
  }
  this.last = function() {
    return this.list[this.list.length - 1];
  }
  this.current = function() {
    if (this.index < this.list.length) {
      return this.list[this.index];
    } else {
      return null;
    }
  }
}
function DefaultSyntaxErrorFormatter() {
  this.unexpected_eof = function(nonterminal, expected_terminals, nonterminal_rules) {
    return "Error: unexpected end of file";
  }
  this.excess_tokens = function(nonterminal, terminal) {
    return "Finished parsing without consuming all tokens.";
  }
  this.unexpected_symbol = function(nonterminal, actual_terminal, expected_terminals, rule) {
    return "Unexpected symbol (line {0}, col {1}) when parsing parse_{2}.  Expected {3}, got {4}.".format(
      actual_terminal.line,
      actual_terminal.col,
      nonterminal,
      expected_terminals.join(', '),
      actual_terminal.to_string(true)
    );
  }
  this.no_more_tokens = function(nonterminal, expected_terminal, last_terminal) {
    return "No more tokens.  Expecting " + expected_terminal;
  }
  this.invalid_terminal = function(nonterminal, invalid_terminal) {
    return "Invalid symbol ID: {0} ({1})".format(invalid_terminal.id, invalid_terminal.string);
  }
  this.missing_list_items = function(method, required, found, last) {
    return "List for "+method+" requires "+required+" items but only "+found+" were found.";
  }
  this.missing_terminator = function(method, terminator, last) {
    return "List for "+method+" is missing a terminator";
  }
}
function ParserContext(tokens, error_formatter) {
  this.tokens = tokens;
  this.error_formatter = error_formatter;
  this.nonterminal_string = null;
  this.rule_string = null;
}
function MultiRegExp(par) {
  var regex;
  if (par.source !== undefined){
    regex = par;
  } else {
    var exp = par;
    var opts = "";
    if (par.substring(0, 1) == "/") {
      var l = par.lastIndexOf("/");
      opts = par.substring(l + 1, par.length);
      exp = par.substring(1, l);
    }
    regex = new RegExp(exp, opts);
  }
  var expandSource = function (braces, indexer) {
    ret = '';
    for (var i = 0; i < braces.length; i++) {
      if (braces[i].type == 'raw') {
        ret += '(' + braces[i].text + ')';
        indexer.next();
      } else if (braces[i].type == 'brace' && braces[i].containsCapture) {
        ret += braces[i].pre + expandSource(braces[i].children, indexer) + braces[i].post;
      } else if (braces[i].type == 'brace' && !braces[i].isCapture) {
        ret += '(' + braces[i].text.substring(braces[i].pre.length, braces[i].text.length - braces[i].post.length) + ')';
        indexer.next();
      } else if (braces[i].type == 'brace') {
        ret += braces[i].text;
        indexer.next(true);
      } else {
        ret += braces[i].text;
      }
    }
    return ret;
  }
  var captureScan = function(braces, parent) {
    var containsCapture = false;
    for (var i = 0; i < braces.length; i++) {
      captureScan(braces[i].children, braces[i]);
      braces[i].isCapture = braces[i].text.indexOf('(?:') != 0;
      if (braces[i].isCapture) {
        containsCapture = true;
      }
      if (braces[i].isCapture && braces[i].containsCapture) {
        throw "nested captures not permitted, use (?:...) where capture is not intended";
      }
    }
    if (parent) {
      parent.containsCapture = containsCapture;
    }
  }
  var fillGaps = function(braces, text) {
    var pre = /^\((\?.)?/.exec(text);
    pre = pre == null ? '' : pre[0];
    var post = /\)$/.exec(text);
    post = post == null ? '' : post[0];
    var i = 0;
    if (braces.length > 0) {
      fillGaps(braces[0].children, braces[0].text);
    }
    if (braces.length > 0 && braces[0].pos > pre.length) {
      braces.splice(0, 0, {type: 'raw', pos: pre.length, length: braces[0].pos, text: text.substring(pre.length, braces[0].pos)});
      i++;
    }
    for(i++ ;i < braces.length; i++) {
      fillGaps(braces[i].children, braces[i].text);
      if (braces[i].pos > braces[i-1].pos + braces[i-1].length) {
        braces.splice(i, 0, {type:'raw', pos: braces[i-1].pos + braces[i-1].length,
          length: braces[i].pos - (braces[i-1].pos + braces[i-1].length),
          text: text.substring(braces[i-1].pos + braces[i-1].length,
            braces[i].pos)});
        i++;
      }
    }
    if (braces.length == 0)
    {
      braces.push({type:'raw', pos: pre.length, length: text.length - post.length - pre.length, text: text.substring(pre.length, text.length - post.length)});
    } else if (braces[braces.length - 1].pos + braces[braces.length - 1].length < text.length - post.length) {
      var pos = braces[braces.length - 1].pos + braces[braces.length - 1].length;
      var txt = text.substring(pos, text.length - post.length);
      braces.push({type:'raw', pos: pos, length: txt.length, text: txt});
    }
  }
  var GetBraces = function(text) {
    var ret = [];
    var shift = 0;
    do {
      var brace = GetBrace(text);
      if (brace == null) {
        break;
      } else {
        text = text.substring(brace.pos + brace.length);
        var del = brace.pos + brace.length;
        brace.pos += shift;
        shift += del;
        ret.push(brace);
      }
    } while (brace != null);
    return ret;
  }
  var GetBrace = function(text) {
    var ret = {pos: -1, length: 0, text: '', children: [], type: 'brace'};
    var openExp = /^(?:\\.|[^\)\\\(])*\(\?./;
    var pre = 3;
    var post = 1;
    var m = openExp.exec(text);
    if (m == null) {
      m = /^(?:\\.|[^\)\\\(])*\(/.exec(text);
      pre = 1;
    }
    if (m != null) {
      ret.pos = m[0].length - pre;
      ret.children = GetBraces(text.substring(m[0].length));
      for (var i = 0; i < ret.children.length; i++) {
        ret.children[i].pos += pre;
      }
      var closeExp = /^(?:\\.|[^\\\(\)])*\)/;
      var closeExpAlt = /^(?:\\.|[^\\\(\)])*\)\?/;
      var from = ret.children.length <= 0 ? ret.pos + pre :
        ret.children[ret.children.length-1].pos +
        ret.children[ret.children.length-1].length +
        m[0].length - pre;
      var m2 = closeExp.exec(text.substring(from));
      var m3 = closeExpAlt.exec(text.substring(from));
      if (m3 !== null && m3.length - 1 <= m2.length) {
        m2 = m3;
        post = 2;
      }
      if (m2 == null) {
        return null;
      } else {
        ret.length = m2[0].length + from - ret.pos;
        ret.text = text.substring(ret.pos, ret.pos + ret.length);
      }
    }
    if (ret.text == '()' || /^\(\?.\)$/.test(ret.text)) {
      throw 'empty braces not permitted';
    }
    if (ret.pos != -1) {
      ret.pre = ret.text.substring(0, pre);
      ret.post = ret.text.substring(ret.text.length - post, ret.text.length);
    }
    return ret.pos == -1 ? null : ret;
  }
  var fixOrs = function (braces_W_raw) {
    var orFind = /^(\\.|[^\\|])*\|/;
    for (var i = 0; i < braces_W_raw.length; i++) {
      if (braces_W_raw[i].type == 'raw') {
        var fullText = braces_W_raw[i].text;
        var m = orFind.exec(fullText);
        if (m != null) {
          var or = { type: 'or', pos: m[0].length - 1 + braces_W_raw[i].pos, length: 1, text: '|' };
          var raw = { type: 'raw', pos: m[0].length + braces_W_raw[i].pos,
            length: fullText.length - m[0].length,
            text: fullText.substring(m[0].length, fullText.length)
          };
          braces_W_raw[i].text = fullText.substring(0, m[0].length - 1);
          braces_W_raw[i].length = braces_W_raw[i].text.length;
          braces_W_raw.splice(i + 1, 0, or, raw);
          i += 1;
        }
      } else if (braces_W_raw[i].type == 'brace') {
        fixOrs(braces_W_raw[i].children, braces_W_raw[i].text);
      }
    }
  }
  var source = regex.source;
  var braces = GetBraces(source);
  captureScan(braces);
  fillGaps(braces, source);
  fixOrs(braces);
  var indexer = {i: 1, next:
    function (realPoint) {
      if (realPoint) {
        this.points.push(this.i);
      }
      return this.i++;
    }, points: []};
  source = expandSource(braces, indexer);
  this.dataPoints = indexer.points;
  var options = (regex.ignoreCase ? "i" : "") + (regex.global ? "g" : "") + (regex.multiline ? "m" : "");
  this.regex = new RegExp(source, options);
  this.exec = function (text) {
    var m = this.regex.exec(text);
    if (m == null) {
      return {};
    }
    var ret = {};
    var ch = 0;
    for (var i = 1; i < m.length; i++) {
      if (m[i] !== null && m[i] !== undefined) {
        var pos = this.dataPoints.indexOf(i);
        if (pos != -1) {
          ret[pos] = {index: ch, text: m[i]};
        }
        ch += m[i].length;
      }
    }
    for (var i = 0; i < this.dataPoints.length; i++) {
      if (ret[i] === undefined) {
        ret[i] = null;
      }
    }
    return ret;
  }
}
var Base64 = {
  // private property
  _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  // public method for encoding
  encode : function (input) {
    var output = "";
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0;
    input = Base64._utf8_encode(input);
    while (i < input.length) {
      chr1 = input.charCodeAt(i++);
      chr2 = input.charCodeAt(i++);
      chr3 = input.charCodeAt(i++);
      enc1 = chr1 >> 2;
      enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
      enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
      enc4 = chr3 & 63;
      if (isNaN(chr2)) {
        enc3 = enc4 = 64;
      } else if (isNaN(chr3)) {
        enc4 = 64;
      }
      output = output +
        Base64._keyStr.charAt(enc1) + Base64._keyStr.charAt(enc2) +
        Base64._keyStr.charAt(enc3) + Base64._keyStr.charAt(enc4);
    }
    return output;
  },
  // public method for decoding
  decode : function (input) {
    var output = "";
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    while (i < input.length) {
      enc1 = Base64._keyStr.indexOf(input.charAt(i++));
      enc2 = Base64._keyStr.indexOf(input.charAt(i++));
      enc3 = Base64._keyStr.indexOf(input.charAt(i++));
      enc4 = Base64._keyStr.indexOf(input.charAt(i++));
      chr1 = (enc1 << 2) | (enc2 >> 4);
      chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
      chr3 = ((enc3 & 3) << 6) | enc4;
      output = output + String.fromCharCode(chr1);
      if (enc3 != 64) {
        output = output + String.fromCharCode(chr2);
      }
      if (enc4 != 64) {
        output = output + String.fromCharCode(chr3);
      }
    }
    output = Base64._utf8_decode(output);
    return output;
  },
  // private method for UTF-8 encoding
  _utf8_encode : function (string) {
    string = string.replace(/\r\n/g,"\n");
    var utftext = "";
    for (var n = 0; n < string.length; n++) {
      var c = string.charCodeAt(n);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      }
      else if((c > 127) && (c < 2048)) {
        utftext += String.fromCharCode((c >> 6) | 192);
        utftext += String.fromCharCode((c & 63) | 128);
      }
      else {
        utftext += String.fromCharCode((c >> 12) | 224);
        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
        utftext += String.fromCharCode((c & 63) | 128);
      }
    }
    return utftext;
  },
  // private method for UTF-8 decoding
  _utf8_decode : function (utftext) {
    var string = "";
    var i = 0;
    var c = c1 = c2 = 0;
    while ( i < utftext.length ) {
      c = utftext.charCodeAt(i);
      if (c < 128) {
        string += String.fromCharCode(c);
        i++;
      }
      else if((c > 191) && (c < 224)) {
        c2 = utftext.charCodeAt(i+1);
        string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
        i += 2;
      }
      else {
        c2 = utftext.charCodeAt(i+1);
        c3 = utftext.charCodeAt(i+2);
        string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
        i += 3;
      }
    }
    return string;
  }
}
// Section: Parser
var terminals = {
  0: 'comma',
  1: 'cmd_part',
  2: 'raw_cmd_end',
  3: 'then',
  4: 'task',
  5: 'rparen',
  6: 'while',
  7: 'cmd_attr_hint',
  8: 'double_ampersand',
  9: 'colon',
  10: 'asterisk',
  11: 'e',
  12: 'call',
  13: 'not_equal',
  14: 'boolean',
  15: 'not',
  16: 'runtime',
  17: 'float',
  18: 'qmark',
  19: 'dash',
  20: 'cmd_param_end',
  21: 'plus',
  22: 'double_equal',
  23: 'output',
  24: 'in',
  25: 'scatter',
  26: 'gteq',
  27: 'string',
  28: 'rsquare',
  29: 'as',
  30: 'gt',
  31: 'input',
  32: 'slash',
  33: 'meta',
  34: 'integer',
  35: 'dot',
  36: 'import',
  37: 'raw_cmd_start',
  38: 'lsquare',
  39: 'identifier',
  40: 'fqn',
  41: 'type',
  42: 'lbrace',
  43: 'lparen',
  44: 'parameter_meta',
  45: 'equal',
  46: 'if',
  47: 'lteq',
  48: 'type_e',
  49: 'raw_command',
  50: 'workflow',
  51: 'rbrace',
  52: 'else',
  53: 'double_pipe',
  54: 'cmd_param_start',
  55: 'lt',
  56: 'object',
  57: 'percent',
  'comma': 0,
  'cmd_part': 1,
  'raw_cmd_end': 2,
  'then': 3,
  'task': 4,
  'rparen': 5,
  'while': 6,
  'cmd_attr_hint': 7,
  'double_ampersand': 8,
  'colon': 9,
  'asterisk': 10,
  'e': 11,
  'call': 12,
  'not_equal': 13,
  'boolean': 14,
  'not': 15,
  'runtime': 16,
  'float': 17,
  'qmark': 18,
  'dash': 19,
  'cmd_param_end': 20,
  'plus': 21,
  'double_equal': 22,
  'output': 23,
  'in': 24,
  'scatter': 25,
  'gteq': 26,
  'string': 27,
  'rsquare': 28,
  'as': 29,
  'gt': 30,
  'input': 31,
  'slash': 32,
  'meta': 33,
  'integer': 34,
  'dot': 35,
  'import': 36,
  'raw_cmd_start': 37,
  'lsquare': 38,
  'identifier': 39,
  'fqn': 40,
  'type': 41,
  'lbrace': 42,
  'lparen': 43,
  'parameter_meta': 44,
  'equal': 45,
  'if': 46,
  'lteq': 47,
  'type_e': 48,
  'raw_command': 49,
  'workflow': 50,
  'rbrace': 51,
  'else': 52,
  'double_pipe': 53,
  'cmd_param_start': 54,
  'lt': 55,
  'object': 56,
  'percent': 57,
}
// table[nonterminal][terminal] = rule
var table = [
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 28, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, 35, -1, 35, -1, -1, -1, -1, -1, 35, -1, -1, -1, 35, -1, -1, -1, -1, -1, -1, 35, -1, 35, -1, -1, -1, -1, -1, 35, -1, 35, -1, -1, -1, -1, -1, -1, -1, 35, -1, -1, 35, 34, 35, -1, 35, 35, 35, 35, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 58, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, 71, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 63, 62, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 64, -1, -1, -1, -1, -1, -1, 64, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, -1, -1, -1, -1, -1, -1, 36, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 37, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 67, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 70, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 68, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 65, -1, -1, -1, -1, 66, 66, -1, -1, -1, -1, -1, -1, 66, -1, -1, 66, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 38, -1, -1, 38, 38, -1, 38, -1, 38, -1, 38, -1, -1, -1, -1, -1, 38, -1, -1, -1, -1, -1, -1, 38, -1, -1, -1, 38, 38, -1, -1, 38, 38, -1, -1, 38, -1, -1, -1, -1, -1, -1, -1, -1, -1, 38, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 59, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, 24, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, 7, -1, 7, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, 5, -1, 3, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 23, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 73, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 69, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, 20, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, 52, -1, -1, -1, -1, -1, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, -1, 52, -1, -1, -1, -1, -1, -1, -1, 52, -1, -1, -1, -1, -1, -1, -1, 52, 51, -1, 52, -1, 52, -1, 52, -1, -1, 52, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, 2, -1, 2, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 72, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 16, -1, -1, -1, -1, 13, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 50, -1, 50, -1, -1, -1, 49, -1, -1, -1, 50, -1, -1, -1, -1, -1, -1, -1, 50, 50, -1, 50, -1, 50, -1, 50, -1, -1, 50, -1, -1, -1, -1, -1, -1],
  [-1, -1, -1, -1, -1, -1, 43, -1, -1, -1, -1, -1, 41, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 46, -1, 45, -1, -1, -1, -1, -1, -1, -1, 48, -1, -1, -1, -1, -1, -1, -1, 42, -1, -1, 47, -1, 44, -1, 42, -1, -1, -1, -1, -1, -1, -1, -1, -1],
]
var nonterminal_first = {
  58: [16],
  59: [45, -1],
  60: [39, -1],
  61: [39],
  62: [6],
  63: [40, 41, 48],
  64: [41, 48],
  65: [41, 48],
  66: [45],
  67: [50],
  68: [41, 48],
  69: [40],
  70: [33],
  71: [35],
  72: [35, -1],
  73: [15, 19, 43, 21, 34, 17, 42, 38, 46, 39, 56, 14, 27, 11],
  74: [29],
  75: [36, -1],
  76: [41, 48],
  77: [41, 48, -1],
  78: [7],
  79: [27, 15, 14, 19, 43, 21, 34, 17, 38, 39, 56, 42, 46, 11],
  80: [33],
  81: [41, 48, -1],
  82: [31, -1],
  83: [29, -1],
  84: [39],
  85: [23],
  86: [48, 50, 4, 41, -1],
  87: [41, 48, 50, 4],
  88: [48, 40, 41, -1],
  89: [39],
  90: [34, 38, 39, 14, 42, 11, 17, 43, 46, 15, 19, 21, 56, 27, -1],
  91: [29],
  92: [54],
  93: [42],
  94: [49, 16, 23, 44, 33, -1],
  95: [7, -1],
  96: [39, -1],
  97: [4],
  98: [25],
  99: [44],
  100: [1, 54],
  101: [42, -1],
  102: [36, 48, 50, 4, 41, -1],
  103: [42],
  104: [12, 48, 44, 6, 33, 23, 25, 41, 46, -1],
  105: [44],
  106: [46],
  107: [12],
  108: [49],
  109: [39, -1],
  110: [34, 38, 39, 43, 42, 11, 17, 46, 14, 15, 19, 21, 56, 27, -1],
  111: [44, 33, 49, 16, 23],
  112: [23],
  113: [1, 54, -1],
  114: [31],
  115: [41, 48, -1],
  116: [36],
  117: [29, -1],
  118: [12, 48, 6, 33, 23, 25, 41, 46, 44],
}
var nonterminal_follow = {
  58: [49, 16, 51, 33, 23, 44],
  59: [4, 31, 6, 33, 41, 46, 44, 12, 48, 50, 49, 16, 51, -1, 23, 25],
  60: [51],
  61: [0, 31, 51],
  62: [12, 48, 51, 6, 33, 23, 25, 41, 46, 44],
  63: [48, 51, 40, 41],
  64: [48, 51, 40, 41],
  65: [4, 31, 6, 33, 41, 46, 44, 12, 48, 50, 49, 16, 51, -1, 23, 25],
  66: [4, 31, 6, 33, 41, 46, 44, 12, 48, 50, 49, 16, 51, -1, 23, 25],
  67: [48, 50, 4, -1, 41],
  68: [41, 48, 51],
  69: [48, 51, 40, 41],
  70: [12, 48, 51, 6, 33, 23, 25, 41, 46, 44],
  71: [48, 51, 40, 41],
  72: [48, 51, 40, 41],
  73: [0, 51],
  74: [12, 48, 51, 6, 33, 23, 25, 41, 42, 46, 44],
  75: [-1, 41, 48, 50, 4],
  76: [0, 39, 28],
  77: [28],
  78: [34, 38, 39, 7, 14, 43, 11, 42, 46, 17, 15, 19, 21, 56, 27],
  79: [0, 3, 5, 4, 6, 7, 13, 8, 10, 9, 14, 11, 17, 15, 12, 16, 19, 20, 22, 21, 23, 25, 26, 27, 28, 30, 31, 32, 34, 33, 38, 39, 40, 41, 42, 43, 46, 44, 47, 48, 50, 49, 51, 52, -1, 53, 55, 56, 57],
  80: [49, 16, 51, 33, 23, 44],
  81: [51],
  82: [51],
  83: [-1, 36, 48, 50, 4, 41],
  84: [39, 51],
  85: [12, 48, 51, 6, 33, 23, 25, 41, 46, 44],
  86: [-1],
  87: [48, 50, 4, -1, 41],
  88: [51],
  89: [0, 51],
  90: [51],
  91: [-1, 36, 48, 50, 4, 41],
  92: [1, 2, 54],
  93: [12, 48, 51, 6, 33, 23, 25, 41, 46, 44],
  94: [51],
  95: [27, 15, 14, 19, 43, 21, 34, 17, 38, 39, 56, 42, 46, 11],
  96: [31, 51],
  97: [48, 50, 4, -1, 41],
  98: [12, 48, 51, 6, 33, 23, 25, 41, 46, 44],
  99: [12, 48, 51, 6, 33, 23, 25, 41, 46, 44],
  100: [1, 2, 54],
  101: [12, 48, 51, 6, 33, 23, 25, 41, 46, 44],
  102: [-1],
  103: [12, 48, 49, 16, 51, 6, 33, 23, 25, 41, 46, 44],
  104: [51],
  105: [49, 16, 51, 33, 23, 44],
  106: [12, 48, 51, 6, 33, 23, 25, 41, 46, 44],
  107: [12, 48, 51, 6, 33, 23, 25, 41, 46, 44],
  108: [49, 16, 51, 33, 23, 44],
  109: [51],
  110: [28, 5],
  111: [49, 16, 51, 33, 23, 44],
  112: [49, 16, 51, 33, 23, 44],
  113: [2],
  114: [31, 51],
  115: [49, 16, 23, 31, 33, 44],
  116: [-1, 36, 48, 50, 4, 41],
  117: [12, 48, 51, 6, 33, 23, 25, 41, 42, 46, 44],
  118: [12, 48, 51, 6, 33, 23, 25, 41, 46, 44],
}
var rule_first = {
  0: [36, -1],
  1: [41, 48, 50, 4, -1],
  2: [48, 50, 4, 36, 41, -1],
  3: [50],
  4: [4],
  5: [41, 48],
  6: [29],
  7: [-1],
  8: [36],
  9: [29],
  10: [41, 48, -1],
  11: [49, 16, 33, -1, 23, 44],
  12: [4],
  13: [49],
  14: [23],
  15: [16],
  16: [44],
  17: [33],
  18: [1, -1, 54],
  19: [49],
  20: [1],
  21: [54],
  22: [7, -1],
  23: [54],
  24: [7],
  25: [41, 48, -1],
  26: [23],
  27: [41, 48],
  28: [16],
  29: [44],
  30: [33],
  31: [39, -1],
  32: [42],
  33: [39],
  34: [45],
  35: [-1],
  36: [41, 48],
  37: [45],
  38: [27, 15, 14, 19, 43, 21, 34, 17, 38, 39, 56, 42, 46, 11],
  39: [12, 48, 6, 33, -1, 23, 25, 41, 46, 44],
  40: [50],
  41: [12],
  42: [41, 48],
  43: [6],
  44: [46],
  45: [25],
  46: [23],
  47: [44],
  48: [33],
  49: [29],
  50: [-1],
  51: [42],
  52: [-1],
  53: [12],
  54: [31, -1],
  55: [42],
  56: [39, -1],
  57: [31],
  58: [39],
  59: [29],
  60: [40, 41, 48, -1],
  61: [23],
  62: [41, 48],
  63: [40],
  64: [41, 48],
  65: [35],
  66: [-1],
  67: [40],
  68: [35],
  69: [44],
  70: [33],
  71: [6],
  72: [46],
  73: [25],
  74: [39],
  75: [41, 48, -1],
  76: [41],
  77: [41],
  78: [41],
  79: [41],
  80: [27, 15, 14, 19, 43, 21, 34, 17, 38, 39, 56, 42, 46, 11],
  81: [27, 15, 14, 19, 43, 21, 34, 17, 38, 39, 56, 42, 46, 11],
  82: [27, 15, 14, 19, 43, 21, 34, 17, 38, 39, 56, 42, 46, 11],
  83: [27, 15, 14, 19, 43, 21, 34, 17, 38, 39, 56, 42, 46, 11],
  84: [27, 15, 14, 19, 43, 21, 34, 17, 38, 39, 56, 42, 46, 11],
  85: [27, 15, 14, 19, 43, 21, 34, 17, 38, 39, 56, 42, 46, 11],
  86: [27, 15, 14, 19, 43, 21, 34, 17, 38, 39, 56, 42, 46, 11],
  87: [27, 15, 14, 19, 43, 21, 34, 17, 38, 39, 56, 42, 46, 11],
  88: [27, 15, 14, 19, 43, 21, 34, 17, 38, 39, 56, 42, 46, 11],
  89: [27, 15, 14, 19, 43, 21, 34, 17, 38, 39, 56, 42, 46, 11],
  90: [27, 15, 14, 19, 43, 21, 34, 17, 38, 39, 56, 42, 46, 11],
  91: [27, 15, 14, 19, 43, 21, 34, 17, 38, 39, 56, 42, 46, 11],
  92: [27, 15, 14, 19, 43, 21, 34, 17, 38, 39, 56, 42, 46, 11],
  93: [15],
  94: [21],
  95: [19],
  96: [27, 15, 14, 19, 43, 21, 34, 17, -1, 38, 39, 56, 42, 46, 11],
  97: [39],
  98: [39],
  99: [39],
  100: [39, -1],
  101: [56],
  102: [38],
  103: [15, 19, 43, 21, 34, 17, 42, -1, 38, 46, 39, 56, 14, 27, 11],
  104: [42],
  105: [43],
  106: [46],
  107: [27],
  108: [39],
  109: [14],
  110: [34],
  111: [17],
}
var nonterminal_rules = {
  58: [
    "$runtime = :runtime $map -> Runtime( map=$1 )",
  ],
  59: [
    "$_gen9 = $setter",
    "$_gen9 = :_empty",
  ],
  60: [
    "$_gen8 = list($kv)",
  ],
  61: [
    "$mapping = :identifier :equal $e -> IOMapping( key=$0, value=$2 )",
  ],
  62: [
    "$while_loop = :while :lparen $e :rparen :lbrace $_gen10 :rbrace -> WhileLoop( expression=$2, body=$5 )",
  ],
  63: [
    "$wf_output = $wf_output_declaration_syntax",
    "$wf_output = $wf_output_wildcard_syntax",
  ],
  64: [
    "$wf_output_declaration_syntax = $type_e :identifier :equal $e -> WorkflowOutputDeclaration( type=$0, name=$1, expression=$3 )",
  ],
  65: [
    "$declaration = $type_e :identifier $_gen9 -> Declaration( type=$0, name=$1, expression=$2 )",
  ],
  66: [
    "$setter = :equal $e -> $1",
  ],
  67: [
    "$workflow = :workflow :identifier :lbrace $_gen10 :rbrace -> Workflow( name=$1, body=$3 )",
  ],
  68: [
    "$output_kv = $type_e :identifier :equal $e -> Output( type=$0, name=$1, expression=$3 )",
  ],
  69: [
    "$wf_output_wildcard_syntax = :fqn $_gen16 -> WorkflowOutputWildcard( fqn=$0, wildcard=$1 )",
  ],
  70: [
    "$wf_meta = :meta $map -> Meta( map=$1 )",
  ],
  71: [
    "$wf_output_wildcard = :dot :asterisk -> $1",
  ],
  72: [
    "$_gen16 = $wf_output_wildcard",
    "$_gen16 = :_empty",
  ],
  73: [
    "$map_kv = $e :colon $e -> MapLiteralKv( key=$0, value=$2 )",
  ],
  74: [
    "$alias = :as :identifier -> $1",
  ],
  75: [
    "$_gen0 = list($import)",
  ],
  76: [
    "$type_e = :type <=> :lsquare $_gen17 :rsquare -> Type( name=$0, subtype=$2 )",
    "$type_e = :type <=> :qmark -> OptionalType( innerType=$0 )",
    "$type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )",
    "$type_e = :type",
  ],
  77: [
    "$_gen17 = list($type_e, :comma)",
  ],
  78: [
    "$cmd_param_kv = :cmd_attr_hint :identifier :equal $e -> CommandParameterAttr( key=$1, value=$3 )",
  ],
  79: [
    "$e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )",
    "$e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )",
    "$e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )",
    "$e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )",
    "$e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )",
    "$e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )",
    "$e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )",
    "$e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )",
    "$e = $e :plus $e -> Add( lhs=$0, rhs=$2 )",
    "$e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )",
    "$e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )",
    "$e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )",
    "$e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )",
    "$e = :not $e -> LogicalNot( expression=$1 )",
    "$e = :plus $e -> UnaryPlus( expression=$1 )",
    "$e = :dash $e -> UnaryNegation( expression=$1 )",
    "$e = :identifier <=> :lparen $_gen18 :rparen -> FunctionCall( name=$0, params=$2 )",
    "$e = :identifier <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )",
    "$e = :identifier <=> :dot :identifier -> MemberAccess( lhs=$0, rhs=$2 )",
    "$e = :object :lbrace $_gen19 :rbrace -> ObjectLiteral( map=$2 )",
    "$e = :lsquare $_gen18 :rsquare -> ArrayLiteral( values=$1 )",
    "$e = :lbrace $_gen20 :rbrace -> MapLiteral( map=$1 )",
    "$e = :lparen $_gen18 :rparen -> TupleLiteral( values=$1 )",
    "$e = :if $e :then $e :else $e -> TernaryIf( cond=$1, iftrue=$3, iffalse=$5 )",
    "$e = :string",
    "$e = :identifier",
    "$e = :boolean",
    "$e = :integer",
    "$e = :float",
  ],
  80: [
    "$meta = :meta $map -> Meta( map=$1 )",
  ],
  81: [
    "$_gen7 = list($output_kv)",
  ],
  82: [
    "$_gen13 = list($call_input)",
  ],
  83: [
    "$_gen2 = $import_namespace",
    "$_gen2 = :_empty",
  ],
  84: [
    "$kv = :identifier :colon $e -> RuntimeAttribute( key=$0, value=$2 )",
  ],
  85: [
    "$wf_outputs = :output :lbrace $_gen15 :rbrace -> WorkflowOutputs( outputs=$2 )",
  ],
  86: [
    "$_gen1 = list($workflow_or_task_or_decl)",
  ],
  87: [
    "$workflow_or_task_or_decl = $workflow",
    "$workflow_or_task_or_decl = $task",
    "$workflow_or_task_or_decl = $declaration",
  ],
  88: [
    "$_gen15 = list($wf_output)",
  ],
  89: [
    "$object_kv = :identifier :colon $e -> ObjectKV( key=$0, value=$2 )",
  ],
  90: [
    "$_gen20 = list($map_kv, :comma)",
  ],
  91: [
    "$import_namespace = :as :identifier -> $1",
  ],
  92: [
    "$cmd_param = :cmd_param_start $_gen6 $e :cmd_param_end -> CommandParameter( attributes=$1, expr=$2 )",
  ],
  93: [
    "$call_body = :lbrace $_gen3 $_gen13 :rbrace -> CallBody( declarations=$1, io=$2 )",
  ],
  94: [
    "$_gen4 = list($sections)",
  ],
  95: [
    "$_gen6 = list($cmd_param_kv)",
  ],
  96: [
    "$_gen14 = list($mapping, :comma)",
  ],
  97: [
    "$task = :task :identifier :lbrace $_gen3 $_gen4 :rbrace -> Task( name=$1, declarations=$3, sections=$4 )",
  ],
  98: [
    "$scatter = :scatter :lparen :identifier :in $e :rparen :lbrace $_gen10 :rbrace -> Scatter( item=$2, collection=$4, body=$7 )",
  ],
  99: [
    "$wf_parameter_meta = :parameter_meta $map -> ParameterMeta( map=$1 )",
  ],
  100: [
    "$command_part = :cmd_part",
    "$command_part = $cmd_param",
  ],
  101: [
    "$_gen12 = $call_body",
    "$_gen12 = :_empty",
  ],
  102: [
    "$document = $_gen0 $_gen1 -> Namespace( imports=$0, body=$1 )",
  ],
  103: [
    "$map = :lbrace $_gen8 :rbrace -> $1",
  ],
  104: [
    "$_gen10 = list($wf_body_element)",
  ],
  105: [
    "$parameter_meta = :parameter_meta $map -> ParameterMeta( map=$1 )",
  ],
  106: [
    "$if_stmt = :if :lparen $e :rparen :lbrace $_gen10 :rbrace -> If( expression=$2, body=$5 )",
  ],
  107: [
    "$call = :call :fqn $_gen11 $_gen12 -> Call( task=$1, alias=$2, body=$3 )",
  ],
  108: [
    "$command = :raw_command :raw_cmd_start $_gen5 :raw_cmd_end -> RawCommand( parts=$2 )",
  ],
  109: [
    "$_gen19 = list($object_kv, :comma)",
  ],
  110: [
    "$_gen18 = list($e, :comma)",
  ],
  111: [
    "$sections = $command",
    "$sections = $outputs",
    "$sections = $runtime",
    "$sections = $parameter_meta",
    "$sections = $meta",
  ],
  112: [
    "$outputs = :output :lbrace $_gen7 :rbrace -> Outputs( attributes=$2 )",
  ],
  113: [
    "$_gen5 = list($command_part)",
  ],
  114: [
    "$call_input = :input :colon $_gen14 -> Inputs( map=$2 )",
  ],
  115: [
    "$_gen3 = list($declaration)",
  ],
  116: [
    "$import = :import :string $_gen2 -> Import( uri=$1, namespace=$2 )",
  ],
  117: [
    "$_gen11 = $alias",
    "$_gen11 = :_empty",
  ],
  118: [
    "$wf_body_element = $call",
    "$wf_body_element = $declaration",
    "$wf_body_element = $while_loop",
    "$wf_body_element = $if_stmt",
    "$wf_body_element = $scatter",
    "$wf_body_element = $wf_outputs",
    "$wf_body_element = $wf_parameter_meta",
    "$wf_body_element = $wf_meta",
  ],
}
var rules = {
  0: "$_gen0 = list($import)",
  1: "$_gen1 = list($workflow_or_task_or_decl)",
  2: "$document = $_gen0 $_gen1 -> Namespace( imports=$0, body=$1 )",
  3: "$workflow_or_task_or_decl = $workflow",
  4: "$workflow_or_task_or_decl = $task",
  5: "$workflow_or_task_or_decl = $declaration",
  6: "$_gen2 = $import_namespace",
  7: "$_gen2 = :_empty",
  8: "$import = :import :string $_gen2 -> Import( uri=$1, namespace=$2 )",
  9: "$import_namespace = :as :identifier -> $1",
  10: "$_gen3 = list($declaration)",
  11: "$_gen4 = list($sections)",
  12: "$task = :task :identifier :lbrace $_gen3 $_gen4 :rbrace -> Task( name=$1, declarations=$3, sections=$4 )",
  13: "$sections = $command",
  14: "$sections = $outputs",
  15: "$sections = $runtime",
  16: "$sections = $parameter_meta",
  17: "$sections = $meta",
  18: "$_gen5 = list($command_part)",
  19: "$command = :raw_command :raw_cmd_start $_gen5 :raw_cmd_end -> RawCommand( parts=$2 )",
  20: "$command_part = :cmd_part",
  21: "$command_part = $cmd_param",
  22: "$_gen6 = list($cmd_param_kv)",
  23: "$cmd_param = :cmd_param_start $_gen6 $e :cmd_param_end -> CommandParameter( attributes=$1, expr=$2 )",
  24: "$cmd_param_kv = :cmd_attr_hint :identifier :equal $e -> CommandParameterAttr( key=$1, value=$3 )",
  25: "$_gen7 = list($output_kv)",
  26: "$outputs = :output :lbrace $_gen7 :rbrace -> Outputs( attributes=$2 )",
  27: "$output_kv = $type_e :identifier :equal $e -> Output( type=$0, name=$1, expression=$3 )",
  28: "$runtime = :runtime $map -> Runtime( map=$1 )",
  29: "$parameter_meta = :parameter_meta $map -> ParameterMeta( map=$1 )",
  30: "$meta = :meta $map -> Meta( map=$1 )",
  31: "$_gen8 = list($kv)",
  32: "$map = :lbrace $_gen8 :rbrace -> $1",
  33: "$kv = :identifier :colon $e -> RuntimeAttribute( key=$0, value=$2 )",
  34: "$_gen9 = $setter",
  35: "$_gen9 = :_empty",
  36: "$declaration = $type_e :identifier $_gen9 -> Declaration( type=$0, name=$1, expression=$2 )",
  37: "$setter = :equal $e -> $1",
  38: "$map_kv = $e :colon $e -> MapLiteralKv( key=$0, value=$2 )",
  39: "$_gen10 = list($wf_body_element)",
  40: "$workflow = :workflow :identifier :lbrace $_gen10 :rbrace -> Workflow( name=$1, body=$3 )",
  41: "$wf_body_element = $call",
  42: "$wf_body_element = $declaration",
  43: "$wf_body_element = $while_loop",
  44: "$wf_body_element = $if_stmt",
  45: "$wf_body_element = $scatter",
  46: "$wf_body_element = $wf_outputs",
  47: "$wf_body_element = $wf_parameter_meta",
  48: "$wf_body_element = $wf_meta",
  49: "$_gen11 = $alias",
  50: "$_gen11 = :_empty",
  51: "$_gen12 = $call_body",
  52: "$_gen12 = :_empty",
  53: "$call = :call :fqn $_gen11 $_gen12 -> Call( task=$1, alias=$2, body=$3 )",
  54: "$_gen13 = list($call_input)",
  55: "$call_body = :lbrace $_gen3 $_gen13 :rbrace -> CallBody( declarations=$1, io=$2 )",
  56: "$_gen14 = list($mapping, :comma)",
  57: "$call_input = :input :colon $_gen14 -> Inputs( map=$2 )",
  58: "$mapping = :identifier :equal $e -> IOMapping( key=$0, value=$2 )",
  59: "$alias = :as :identifier -> $1",
  60: "$_gen15 = list($wf_output)",
  61: "$wf_outputs = :output :lbrace $_gen15 :rbrace -> WorkflowOutputs( outputs=$2 )",
  62: "$wf_output = $wf_output_declaration_syntax",
  63: "$wf_output = $wf_output_wildcard_syntax",
  64: "$wf_output_declaration_syntax = $type_e :identifier :equal $e -> WorkflowOutputDeclaration( type=$0, name=$1, expression=$3 )",
  65: "$_gen16 = $wf_output_wildcard",
  66: "$_gen16 = :_empty",
  67: "$wf_output_wildcard_syntax = :fqn $_gen16 -> WorkflowOutputWildcard( fqn=$0, wildcard=$1 )",
  68: "$wf_output_wildcard = :dot :asterisk -> $1",
  69: "$wf_parameter_meta = :parameter_meta $map -> ParameterMeta( map=$1 )",
  70: "$wf_meta = :meta $map -> Meta( map=$1 )",
  71: "$while_loop = :while :lparen $e :rparen :lbrace $_gen10 :rbrace -> WhileLoop( expression=$2, body=$5 )",
  72: "$if_stmt = :if :lparen $e :rparen :lbrace $_gen10 :rbrace -> If( expression=$2, body=$5 )",
  73: "$scatter = :scatter :lparen :identifier :in $e :rparen :lbrace $_gen10 :rbrace -> Scatter( item=$2, collection=$4, body=$7 )",
  74: "$object_kv = :identifier :colon $e -> ObjectKV( key=$0, value=$2 )",
  75: "$_gen17 = list($type_e, :comma)",
  76: "$type_e = :type <=> :lsquare $_gen17 :rsquare -> Type( name=$0, subtype=$2 )",
  77: "$type_e = :type <=> :qmark -> OptionalType( innerType=$0 )",
  78: "$type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )",
  79: "$type_e = :type",
  80: "$e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )",
  81: "$e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )",
  82: "$e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )",
  83: "$e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )",
  84: "$e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )",
  85: "$e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )",
  86: "$e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )",
  87: "$e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )",
  88: "$e = $e :plus $e -> Add( lhs=$0, rhs=$2 )",
  89: "$e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )",
  90: "$e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )",
  91: "$e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )",
  92: "$e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )",
  93: "$e = :not $e -> LogicalNot( expression=$1 )",
  94: "$e = :plus $e -> UnaryPlus( expression=$1 )",
  95: "$e = :dash $e -> UnaryNegation( expression=$1 )",
  96: "$_gen18 = list($e, :comma)",
  97: "$e = :identifier <=> :lparen $_gen18 :rparen -> FunctionCall( name=$0, params=$2 )",
  98: "$e = :identifier <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )",
  99: "$e = :identifier <=> :dot :identifier -> MemberAccess( lhs=$0, rhs=$2 )",
  100: "$_gen19 = list($object_kv, :comma)",
  101: "$e = :object :lbrace $_gen19 :rbrace -> ObjectLiteral( map=$2 )",
  102: "$e = :lsquare $_gen18 :rsquare -> ArrayLiteral( values=$1 )",
  103: "$_gen20 = list($map_kv, :comma)",
  104: "$e = :lbrace $_gen20 :rbrace -> MapLiteral( map=$1 )",
  105: "$e = :lparen $_gen18 :rparen -> TupleLiteral( values=$1 )",
  106: "$e = :if $e :then $e :else $e -> TernaryIf( cond=$1, iftrue=$3, iffalse=$5 )",
  107: "$e = :string",
  108: "$e = :identifier",
  109: "$e = :boolean",
  110: "$e = :integer",
  111: "$e = :float",
}
function is_terminal(id){
  return 0 <= id && id <= 57;
}
function parse(tokens, error_formatter, start) {
  if (error_formatter === undefined) {
    error_formatter = new DefaultSyntaxErrorFormatter();
  }
  var ctx = new ParserContext(tokens, error_formatter);
  var tree = parse_document(ctx);
  if (tokens.current() != null) {
    throw new SyntaxError('Finished parsing without consuming all tokens.');
  }
  return tree;
}
function expect(ctx, terminal_id) {
  var current = ctx.tokens.current();
  if (current == null) {
    throw new SyntaxError(ctx.error_formatter.no_more_tokens(ctx.nonterminal, terminals[terminal_id], ctx.tokens.last()));
  }
  if (current.id != terminal_id) {
    throw new SyntaxError(ctx.error_formatter.unexpected_symbol(ctx.nonterminal, current, [terminals[terminal_id]], ctx.rule));
  }
  var next = ctx.tokens.advance();
  if (next && !is_terminal(next.id)) {
    throw new SyntaxError(ctx.error_formatter.invalid_terminal(ctx.nonterminal, next));
  }
  return current;
}
// START definitions for expression parser `e`
var infix_binding_power_e = {
  53: 4000, // $e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )
  8: 5000, // $e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )
  22: 6000, // $e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )
  13: 6000, // $e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )
  55: 7000, // $e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )
  47: 7000, // $e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )
  30: 7000, // $e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )
  26: 7000, // $e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )
  21: 8000, // $e = $e :plus $e -> Add( lhs=$0, rhs=$2 )
  19: 8000, // $e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )
  10: 9000, // $e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )
  32: 9000, // $e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )
  57: 9000, // $e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )
  43: 11000, // $e = :identifier <=> :lparen list($e, :comma) :rparen -> FunctionCall( name=$0, params=$2 )
  38: 12000, // $e = :identifier <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )
  35: 13000, // $e = :identifier <=> :dot :identifier -> MemberAccess( lhs=$0, rhs=$2 )
}
var prefix_binding_power_e = {
  15: 10000, // $e = :not $e -> LogicalNot( expression=$1 )
  21: 10000, // $e = :plus $e -> UnaryPlus( expression=$1 )
  19: 10000, // $e = :dash $e -> UnaryNegation( expression=$1 )
}
function get_infix_binding_power_e(terminal_id) {
  if (terminal_id in infix_binding_power_e) {
    return infix_binding_power_e[terminal_id];
  } else {
    return 0;
  }
}
function get_prefix_binding_power_e(terminal_id) {
  if (terminal_id in prefix_binding_power_e) {
    return prefix_binding_power_e[terminal_id];
  } else {
    return 0;
  }
}
function parse_e(ctx) {
  return parse_e_internal(ctx, 0);
}
function parse_e_internal(ctx, rbp) {
  var left = nud_e(ctx);
  if (left instanceof ParseTree) {
    left.isExpr = true;
    left.isNud = true;
  }
  while (ctx.tokens.current() && rbp < get_infix_binding_power_e(ctx.tokens.current().id)) {
    left = led_e(left, ctx);
  }
  if (left) {
    left.isExpr = true;
  }
  return left;
}
function nud_e(ctx) {
  var tree = new ParseTree(new NonTerminal(79, 'e'));
  var current = ctx.tokens.current();
  var ast_parameters;
  ctx.nonterminal = "e";
  if (!current) {
    return tree;
  }
  else if (rule_first[93].indexOf(current.id) != -1) {
    // $e = :not $e -> LogicalNot( expression=$1 )
    ctx.rule = rules[93];
    ast_parameters = {
      'expression': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('LogicalNot', ast_parameters);
    tree.nudMorphemeCount = 2;
    tree.add(expect(ctx, 15));
    tree.add(parse_e_internal(ctx, get_prefix_binding_power_e(15)));
    tree.isPrefix = true;
  }
  else if (rule_first[94].indexOf(current.id) != -1) {
    // $e = :plus $e -> UnaryPlus( expression=$1 )
    ctx.rule = rules[94];
    ast_parameters = {
      'expression': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('UnaryPlus', ast_parameters);
    tree.nudMorphemeCount = 2;
    tree.add(expect(ctx, 21));
    tree.add(parse_e_internal(ctx, get_prefix_binding_power_e(21)));
    tree.isPrefix = true;
  }
  else if (rule_first[95].indexOf(current.id) != -1) {
    // $e = :dash $e -> UnaryNegation( expression=$1 )
    ctx.rule = rules[95];
    ast_parameters = {
      'expression': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('UnaryNegation', ast_parameters);
    tree.nudMorphemeCount = 2;
    tree.add(expect(ctx, 19));
    tree.add(parse_e_internal(ctx, get_prefix_binding_power_e(19)));
    tree.isPrefix = true;
  }
  else if (rule_first[97].indexOf(current.id) != -1) {
    // $e = :identifier <=> :lparen $_gen18 :rparen -> FunctionCall( name=$0, params=$2 )
    ctx.rule = rules[97];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 39));
  }
  else if (rule_first[98].indexOf(current.id) != -1) {
    // $e = :identifier <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )
    ctx.rule = rules[98];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 39));
  }
  else if (rule_first[99].indexOf(current.id) != -1) {
    // $e = :identifier <=> :dot :identifier -> MemberAccess( lhs=$0, rhs=$2 )
    ctx.rule = rules[99];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 39));
  }
  else if (rule_first[101].indexOf(current.id) != -1) {
    // $e = :object :lbrace $_gen19 :rbrace -> ObjectLiteral( map=$2 )
    ctx.rule = rules[101];
    ast_parameters = {
      'map': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('ObjectLiteral', ast_parameters);
    tree.nudMorphemeCount = 4;
    tree.add(expect(ctx, 56));
    tree.add(expect(ctx, 42));
    tree.add(parse__gen19(ctx));
    tree.add(expect(ctx, 51));
  }
  else if (rule_first[102].indexOf(current.id) != -1) {
    // $e = :lsquare $_gen18 :rsquare -> ArrayLiteral( values=$1 )
    ctx.rule = rules[102];
    ast_parameters = {
      'values': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('ArrayLiteral', ast_parameters);
    tree.nudMorphemeCount = 3;
    tree.add(expect(ctx, 38));
    tree.add(parse__gen18(ctx));
    tree.add(expect(ctx, 28));
  }
  else if (rule_first[104].indexOf(current.id) != -1) {
    // $e = :lbrace $_gen20 :rbrace -> MapLiteral( map=$1 )
    ctx.rule = rules[104];
    ast_parameters = {
      'map': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('MapLiteral', ast_parameters);
    tree.nudMorphemeCount = 3;
    tree.add(expect(ctx, 42));
    tree.add(parse__gen20(ctx));
    tree.add(expect(ctx, 51));
  }
  else if (rule_first[105].indexOf(current.id) != -1) {
    // $e = :lparen $_gen18 :rparen -> TupleLiteral( values=$1 )
    ctx.rule = rules[105];
    ast_parameters = {
      'values': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('TupleLiteral', ast_parameters);
    tree.nudMorphemeCount = 3;
    tree.add(expect(ctx, 43));
    tree.add(parse__gen18(ctx));
    tree.add(expect(ctx, 5));
  }
  else if (rule_first[106].indexOf(current.id) != -1) {
    // $e = :if $e :then $e :else $e -> TernaryIf( cond=$1, iftrue=$3, iffalse=$5 )
    ctx.rule = rules[106];
    ast_parameters = {
      'cond': 1,
      'iftrue': 3,
      'iffalse': 5,
    }
    tree.astTransform = new AstTransformNodeCreator('TernaryIf', ast_parameters);
    tree.nudMorphemeCount = 6;
    tree.add(expect(ctx, 46));
    tree.add(parse_e(ctx));
    tree.add(expect(ctx, 3));
    tree.add(parse_e(ctx));
    tree.add(expect(ctx, 52));
    tree.add(parse_e(ctx));
  }
  else if (rule_first[107].indexOf(current.id) != -1) {
    // $e = :string
    ctx.rule = rules[107];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 27));
  }
  else if (rule_first[108].indexOf(current.id) != -1) {
    // $e = :identifier
    ctx.rule = rules[108];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 39));
  }
  else if (rule_first[109].indexOf(current.id) != -1) {
    // $e = :boolean
    ctx.rule = rules[109];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 14));
  }
  else if (rule_first[110].indexOf(current.id) != -1) {
    // $e = :integer
    ctx.rule = rules[110];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 34));
  }
  else if (rule_first[111].indexOf(current.id) != -1) {
    // $e = :float
    ctx.rule = rules[111];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 17));
  }
  return tree;
}
function led_e(left, ctx) {
  var tree = new ParseTree(new NonTerminal(79, 'e'))
  var current = ctx.tokens.current()
  var ast_parameters;
  ctx.nonterminal = "e";
  if (current.id == 53) { // :double_pipe
    // $e = $e :double_pipe $e -> LogicalOr( lhs=$0, rhs=$2 )
    ctx.rule = rules[80];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('LogicalOr', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 53)); // :double_pipe
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(53) - modifier));
  }
  if (current.id == 8) { // :double_ampersand
    // $e = $e :double_ampersand $e -> LogicalAnd( lhs=$0, rhs=$2 )
    ctx.rule = rules[81];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('LogicalAnd', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 8)); // :double_ampersand
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(8) - modifier));
  }
  if (current.id == 22) { // :double_equal
    // $e = $e :double_equal $e -> Equals( lhs=$0, rhs=$2 )
    ctx.rule = rules[82];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Equals', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 22)); // :double_equal
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(22) - modifier));
  }
  if (current.id == 13) { // :not_equal
    // $e = $e :not_equal $e -> NotEquals( lhs=$0, rhs=$2 )
    ctx.rule = rules[83];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('NotEquals', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 13)); // :not_equal
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(13) - modifier));
  }
  if (current.id == 55) { // :lt
    // $e = $e :lt $e -> LessThan( lhs=$0, rhs=$2 )
    ctx.rule = rules[84];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('LessThan', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 55)); // :lt
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(55) - modifier));
  }
  if (current.id == 47) { // :lteq
    // $e = $e :lteq $e -> LessThanOrEqual( lhs=$0, rhs=$2 )
    ctx.rule = rules[85];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('LessThanOrEqual', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 47)); // :lteq
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(47) - modifier));
  }
  if (current.id == 30) { // :gt
    // $e = $e :gt $e -> GreaterThan( lhs=$0, rhs=$2 )
    ctx.rule = rules[86];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('GreaterThan', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 30)); // :gt
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(30) - modifier));
  }
  if (current.id == 26) { // :gteq
    // $e = $e :gteq $e -> GreaterThanOrEqual( lhs=$0, rhs=$2 )
    ctx.rule = rules[87];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('GreaterThanOrEqual', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 26)); // :gteq
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(26) - modifier));
  }
  if (current.id == 21) { // :plus
    // $e = $e :plus $e -> Add( lhs=$0, rhs=$2 )
    ctx.rule = rules[88];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Add', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 21)); // :plus
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(21) - modifier));
  }
  if (current.id == 19) { // :dash
    // $e = $e :dash $e -> Subtract( lhs=$0, rhs=$2 )
    ctx.rule = rules[89];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Subtract', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 19)); // :dash
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(19) - modifier));
  }
  if (current.id == 10) { // :asterisk
    // $e = $e :asterisk $e -> Multiply( lhs=$0, rhs=$2 )
    ctx.rule = rules[90];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Multiply', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 10)); // :asterisk
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(10) - modifier));
  }
  if (current.id == 32) { // :slash
    // $e = $e :slash $e -> Divide( lhs=$0, rhs=$2 )
    ctx.rule = rules[91];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Divide', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 32)); // :slash
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(32) - modifier));
  }
  if (current.id == 57) { // :percent
    // $e = $e :percent $e -> Remainder( lhs=$0, rhs=$2 )
    ctx.rule = rules[92];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Remainder', ast_parameters);
    tree.isExprNud = true;
    tree.add(left);
    tree.add(expect(ctx, 57)); // :percent
    var modifier = 0;
    tree.isInfix = true;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(57) - modifier));
  }
  if (current.id == 43) { // :lparen
    // $e = :identifier <=> :lparen $_gen18 :rparen -> FunctionCall( name=$0, params=$2 )
    ctx.rule = rules[97];
    ast_parameters = {
      'name': 0,
      'params': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('FunctionCall', ast_parameters);
    tree.add(left);
    tree.add(expect(ctx, 43)); // :lparen
    tree.add(parse__gen18(ctx));
    tree.add(expect(ctx, 5)); // :rparen
  }
  if (current.id == 38) { // :lsquare
    // $e = :identifier <=> :lsquare $e :rsquare -> ArrayOrMapLookup( lhs=$0, rhs=$2 )
    ctx.rule = rules[98];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('ArrayOrMapLookup', ast_parameters);
    tree.add(left);
    tree.add(expect(ctx, 38)); // :lsquare
    var modifier = 0;
    tree.add(parse_e_internal(ctx, get_infix_binding_power_e(38) - modifier));
    tree.add(expect(ctx, 28)); // :rsquare
  }
  if (current.id == 35) { // :dot
    // $e = :identifier <=> :dot :identifier -> MemberAccess( lhs=$0, rhs=$2 )
    ctx.rule = rules[99];
    ast_parameters = {
      'lhs': 0,
      'rhs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('MemberAccess', ast_parameters);
    tree.add(left);
    tree.add(expect(ctx, 35)); // :dot
    tree.add(expect(ctx, 39)); // :identifier
  }
  return tree;
}
// END definitions for expression parser `e`
// START definitions for expression parser `type_e`
var infix_binding_power_type_e = {
  38: 1000, // $type_e = :type <=> :lsquare list($type_e, :comma) :rsquare -> Type( name=$0, subtype=$2 )
  18: 2000, // $type_e = :type <=> :qmark -> OptionalType( innerType=$0 )
  21: 3000, // $type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )
}
var prefix_binding_power_type_e = {
}
function get_infix_binding_power_type_e(terminal_id) {
  if (terminal_id in infix_binding_power_type_e) {
    return infix_binding_power_type_e[terminal_id];
  } else {
    return 0;
  }
}
function get_prefix_binding_power_type_e(terminal_id) {
  if (terminal_id in prefix_binding_power_type_e) {
    return prefix_binding_power_type_e[terminal_id];
  } else {
    return 0;
  }
}
function parse_type_e(ctx) {
  return parse_type_e_internal(ctx, 0);
}
function parse_type_e_internal(ctx, rbp) {
  var left = nud_type_e(ctx);
  if (left instanceof ParseTree) {
    left.isExpr = true;
    left.isNud = true;
  }
  while (ctx.tokens.current() && rbp < get_infix_binding_power_type_e(ctx.tokens.current().id)) {
    left = led_type_e(left, ctx);
  }
  if (left) {
    left.isExpr = true;
  }
  return left;
}
function nud_type_e(ctx) {
  var tree = new ParseTree(new NonTerminal(76, 'type_e'));
  var current = ctx.tokens.current();
  var ast_parameters;
  ctx.nonterminal = "type_e";
  if (!current) {
    return tree;
  }
  if (rule_first[76].indexOf(current.id) != -1) {
    // $type_e = :type <=> :lsquare $_gen17 :rsquare -> Type( name=$0, subtype=$2 )
    ctx.rule = rules[76];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 41));
  }
  else if (rule_first[77].indexOf(current.id) != -1) {
    // $type_e = :type <=> :qmark -> OptionalType( innerType=$0 )
    ctx.rule = rules[77];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 41));
  }
  else if (rule_first[78].indexOf(current.id) != -1) {
    // $type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )
    ctx.rule = rules[78];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 41));
  }
  else if (rule_first[79].indexOf(current.id) != -1) {
    // $type_e = :type
    ctx.rule = rules[79];
    tree.astTransform = new AstTransformSubstitution(0);
    tree.nudMorphemeCount = 1;
    tree.add(expect(ctx, 41));
  }
  return tree;
}
function led_type_e(left, ctx) {
  var tree = new ParseTree(new NonTerminal(76, 'type_e'))
  var current = ctx.tokens.current()
  var ast_parameters;
  ctx.nonterminal = "type_e";
  if (current.id == 38) { // :lsquare
    // $type_e = :type <=> :lsquare $_gen17 :rsquare -> Type( name=$0, subtype=$2 )
    ctx.rule = rules[76];
    ast_parameters = {
      'name': 0,
      'subtype': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Type', ast_parameters);
    tree.add(left);
    tree.add(expect(ctx, 38)); // :lsquare
    tree.add(parse__gen17(ctx));
    tree.add(expect(ctx, 28)); // :rsquare
  }
  if (current.id == 18) { // :qmark
    // $type_e = :type <=> :qmark -> OptionalType( innerType=$0 )
    ctx.rule = rules[77];
    ast_parameters = {
      'innerType': 0,
    }
    tree.astTransform = new AstTransformNodeCreator('OptionalType', ast_parameters);
    tree.add(left);
    tree.add(expect(ctx, 18)); // :qmark
  }
  if (current.id == 21) { // :plus
    // $type_e = :type <=> :plus -> NonEmptyType( innerType=$0 )
    ctx.rule = rules[78];
    ast_parameters = {
      'innerType': 0,
    }
    tree.astTransform = new AstTransformNodeCreator('NonEmptyType', ast_parameters);
    tree.add(left);
    tree.add(expect(ctx, 21)); // :plus
  }
  return tree;
}
// END definitions for expression parser `type_e`
function parse__gen0(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[17][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(75, '_gen0'));
  ctx.nonterminal = "_gen0";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if ( ctx.tokens.current() != null &&
    nonterminal_follow[75].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[75].indexOf(ctx.tokens.current().id) == -1 ) {
    return tree;
  }
  if ( ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while ( minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[75].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_import(ctx));
    ctx.nonterminal = "_gen0";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen1(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[28][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(86, '_gen1'));
  ctx.nonterminal = "_gen1";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if ( ctx.tokens.current() != null &&
    nonterminal_follow[86].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[86].indexOf(ctx.tokens.current().id) == -1 ) {
    return tree;
  }
  if ( ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while ( minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[86].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_workflow_or_task_or_decl(ctx));
    ctx.nonterminal = "_gen1";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen10(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[46][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(104, '_gen10'));
  ctx.nonterminal = "_gen10";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if ( ctx.tokens.current() != null &&
    nonterminal_follow[104].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[104].indexOf(ctx.tokens.current().id) == -1 ) {
    return tree;
  }
  if ( ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while ( minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[104].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_wf_body_element(ctx));
    ctx.nonterminal = "_gen10";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen13(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[24][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(82, '_gen13'));
  ctx.nonterminal = "_gen13";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if ( ctx.tokens.current() != null &&
    nonterminal_follow[82].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[82].indexOf(ctx.tokens.current().id) == -1 ) {
    return tree;
  }
  if ( ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while ( minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[82].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_call_input(ctx));
    ctx.nonterminal = "_gen13";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen14(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[38][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(96, '_gen14'));
  ctx.nonterminal = "_gen14";
  tree.list = true;
  tree.listSeparator = 0;
  tree.astTransform = new AstTransformSubstitution(0);
  if ( ctx.tokens.current() != null &&
    nonterminal_follow[96].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[96].indexOf(ctx.tokens.current().id) == -1 ) {
    return tree;
  }
  if ( ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while ( minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[96].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_mapping(ctx));
    ctx.nonterminal = "_gen14";
    if ( ctx.tokens.current() != null && ctx.tokens.current().id == 0) {
      tree.add(expect(ctx, 0));
    } else {
      if (minimum > 1) {
        throw new SyntaxError(ctx.error_formatter.missing_list_items(
          "_gen14",
          0,
          0 - minimum + 1,
          null
        ));
      }
      break;
    }
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen15(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[30][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(88, '_gen15'));
  ctx.nonterminal = "_gen15";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if ( ctx.tokens.current() != null &&
    nonterminal_follow[88].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[88].indexOf(ctx.tokens.current().id) == -1 ) {
    return tree;
  }
  if ( ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while ( minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[88].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_wf_output(ctx));
    ctx.nonterminal = "_gen15";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen17(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[19][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(77, '_gen17'));
  ctx.nonterminal = "_gen17";
  tree.list = true;
  tree.listSeparator = 0;
  tree.astTransform = new AstTransformSubstitution(0);
  if ( ctx.tokens.current() != null &&
    nonterminal_follow[77].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[77].indexOf(ctx.tokens.current().id) == -1 ) {
    return tree;
  }
  if ( ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while ( minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[77].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_type_e(ctx));
    ctx.nonterminal = "_gen17";
    if ( ctx.tokens.current() != null && ctx.tokens.current().id == 0) {
      tree.add(expect(ctx, 0));
    } else {
      if (minimum > 1) {
        throw new SyntaxError(ctx.error_formatter.missing_list_items(
          "_gen17",
          0,
          0 - minimum + 1,
          null
        ));
      }
      break;
    }
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen18(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[52][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(110, '_gen18'));
  ctx.nonterminal = "_gen18";
  tree.list = true;
  tree.listSeparator = 0;
  tree.astTransform = new AstTransformSubstitution(0);
  if ( ctx.tokens.current() != null &&
    nonterminal_follow[110].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[110].indexOf(ctx.tokens.current().id) == -1 ) {
    return tree;
  }
  if ( ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while ( minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[110].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_e(ctx));
    ctx.nonterminal = "_gen18";
    if ( ctx.tokens.current() != null && ctx.tokens.current().id == 0) {
      tree.add(expect(ctx, 0));
    } else {
      if (minimum > 1) {
        throw new SyntaxError(ctx.error_formatter.missing_list_items(
          "_gen18",
          0,
          0 - minimum + 1,
          null
        ));
      }
      break;
    }
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen19(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[51][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(109, '_gen19'));
  ctx.nonterminal = "_gen19";
  tree.list = true;
  tree.listSeparator = 0;
  tree.astTransform = new AstTransformSubstitution(0);
  if ( ctx.tokens.current() != null &&
    nonterminal_follow[109].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[109].indexOf(ctx.tokens.current().id) == -1 ) {
    return tree;
  }
  if ( ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while ( minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[109].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_object_kv(ctx));
    ctx.nonterminal = "_gen19";
    if ( ctx.tokens.current() != null && ctx.tokens.current().id == 0) {
      tree.add(expect(ctx, 0));
    } else {
      if (minimum > 1) {
        throw new SyntaxError(ctx.error_formatter.missing_list_items(
          "_gen19",
          0,
          0 - minimum + 1,
          null
        ));
      }
      break;
    }
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen20(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[32][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(90, '_gen20'));
  ctx.nonterminal = "_gen20";
  tree.list = true;
  tree.listSeparator = 0;
  tree.astTransform = new AstTransformSubstitution(0);
  if ( ctx.tokens.current() != null &&
    nonterminal_follow[90].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[90].indexOf(ctx.tokens.current().id) == -1 ) {
    return tree;
  }
  if ( ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while ( minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[90].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_map_kv(ctx));
    ctx.nonterminal = "_gen20";
    if ( ctx.tokens.current() != null && ctx.tokens.current().id == 0) {
      tree.add(expect(ctx, 0));
    } else {
      if (minimum > 1) {
        throw new SyntaxError(ctx.error_formatter.missing_list_items(
          "_gen20",
          0,
          0 - minimum + 1,
          null
        ));
      }
      break;
    }
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen3(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[57][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(115, '_gen3'));
  ctx.nonterminal = "_gen3";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if ( ctx.tokens.current() != null &&
    nonterminal_follow[115].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[115].indexOf(ctx.tokens.current().id) == -1 ) {
    return tree;
  }
  if ( ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while ( minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[115].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_declaration(ctx));
    ctx.nonterminal = "_gen3";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen4(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[36][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(94, '_gen4'));
  ctx.nonterminal = "_gen4";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if ( ctx.tokens.current() != null &&
    nonterminal_follow[94].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[94].indexOf(ctx.tokens.current().id) == -1 ) {
    return tree;
  }
  if ( ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while ( minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[94].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_sections(ctx));
    ctx.nonterminal = "_gen4";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen5(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[55][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(113, '_gen5'));
  ctx.nonterminal = "_gen5";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if ( ctx.tokens.current() != null &&
    nonterminal_follow[113].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[113].indexOf(ctx.tokens.current().id) == -1 ) {
    return tree;
  }
  if ( ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while ( minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[113].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_command_part(ctx));
    ctx.nonterminal = "_gen5";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen6(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[37][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(95, '_gen6'));
  ctx.nonterminal = "_gen6";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if ( ctx.tokens.current() != null &&
    nonterminal_follow[95].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[95].indexOf(ctx.tokens.current().id) == -1 ) {
    return tree;
  }
  if ( ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while ( minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[95].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_cmd_param_kv(ctx));
    ctx.nonterminal = "_gen6";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen7(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[23][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(81, '_gen7'));
  ctx.nonterminal = "_gen7";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if ( ctx.tokens.current() != null &&
    nonterminal_follow[81].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[81].indexOf(ctx.tokens.current().id) == -1 ) {
    return tree;
  }
  if ( ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while ( minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[81].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_output_kv(ctx));
    ctx.nonterminal = "_gen7";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen8(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[2][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(60, '_gen8'));
  ctx.nonterminal = "_gen8";
  tree.list = true;
  tree.listSeparator = -1;
  tree.astTransform = new AstTransformSubstitution(0);
  if ( ctx.tokens.current() != null &&
    nonterminal_follow[60].indexOf(ctx.tokens.current().id) != -1 &&
    nonterminal_first[60].indexOf(ctx.tokens.current().id) == -1 ) {
    return tree;
  }
  if ( ctx.tokens.current() == null) {
    return tree;
  }
  var minimum = 0;
  while ( minimum > 0 ||
  (ctx.tokens.current() != null &&
  nonterminal_first[60].indexOf(ctx.tokens.current().id) != -1)) {
    tree.add(parse_kv(ctx));
    ctx.nonterminal = "_gen8";
    minimum = Math.max(minimum - 1, 0);
  }
  return tree;
}
function parse__gen11(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[59][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(117, '_gen11'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "_gen11";
  if (current != null && nonterminal_follow[117].indexOf(current.id) != -1 && nonterminal_first[117].indexOf(current.id) == -1) {
    return tree;
  }
  if (current == null) {
    return tree;
  }
  if (rule == 49) { // $_gen11 = $alias
    ctx.rule = rules[49];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_alias(ctx);
    tree.add(subtree);
    return tree;
  }
  return tree;
}
function parse__gen12(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[43][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(101, '_gen12'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "_gen12";
  if (current != null && nonterminal_follow[101].indexOf(current.id) != -1 && nonterminal_first[101].indexOf(current.id) == -1) {
    return tree;
  }
  if (current == null) {
    return tree;
  }
  if (rule == 51) { // $_gen12 = $call_body
    ctx.rule = rules[51];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_call_body(ctx);
    tree.add(subtree);
    return tree;
  }
  return tree;
}
function parse__gen16(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[14][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(72, '_gen16'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "_gen16";
  if (current != null && nonterminal_follow[72].indexOf(current.id) != -1 && nonterminal_first[72].indexOf(current.id) == -1) {
    return tree;
  }
  if (current == null) {
    return tree;
  }
  if (rule == 65) { // $_gen16 = $wf_output_wildcard
    ctx.rule = rules[65];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_wf_output_wildcard(ctx);
    tree.add(subtree);
    return tree;
  }
  return tree;
}
function parse__gen2(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[25][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(83, '_gen2'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "_gen2";
  if (current != null && nonterminal_follow[83].indexOf(current.id) != -1 && nonterminal_first[83].indexOf(current.id) == -1) {
    return tree;
  }
  if (current == null) {
    return tree;
  }
  if (rule == 6) { // $_gen2 = $import_namespace
    ctx.rule = rules[6];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_import_namespace(ctx);
    tree.add(subtree);
    return tree;
  }
  return tree;
}
function parse__gen9(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[1][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(59, '_gen9'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "_gen9";
  if (current != null && nonterminal_follow[59].indexOf(current.id) != -1 && nonterminal_first[59].indexOf(current.id) == -1) {
    return tree;
  }
  if (current == null) {
    return tree;
  }
  if (rule == 34) { // $_gen9 = $setter
    ctx.rule = rules[34];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_setter(ctx);
    tree.add(subtree);
    return tree;
  }
  return tree;
}
function parse_alias(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[16][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(74, 'alias'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "alias";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 59) { // $alias = :as :identifier -> $1
    ctx.rule = rules[59];
    tree.astTransform = new AstTransformSubstitution(1);
    t = expect(ctx, 29); // :as
    tree.add(t);
    t = expect(ctx, 39); // :identifier
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[74],
    rules[59]
  ));
}
function parse_call(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[49][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(107, 'call'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "call";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 53) { // $call = :call :fqn $_gen11 $_gen12 -> Call( task=$1, alias=$2, body=$3 )
    ctx.rule = rules[53];
    ast_parameters = {
      'task': 1,
      'alias': 2,
      'body': 3,
    }
    tree.astTransform = new AstTransformNodeCreator('Call', ast_parameters);
    t = expect(ctx, 12); // :call
    tree.add(t);
    t = expect(ctx, 40); // :fqn
    tree.add(t);
    subtree = parse__gen11(ctx);
    tree.add(subtree);
    subtree = parse__gen12(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[107],
    rules[53]
  ));
}
function parse_call_body(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[35][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(93, 'call_body'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "call_body";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 55) { // $call_body = :lbrace $_gen3 $_gen13 :rbrace -> CallBody( declarations=$1, io=$2 )
    ctx.rule = rules[55];
    ast_parameters = {
      'declarations': 1,
      'io': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('CallBody', ast_parameters);
    t = expect(ctx, 42); // :lbrace
    tree.add(t);
    subtree = parse__gen3(ctx);
    tree.add(subtree);
    subtree = parse__gen13(ctx);
    tree.add(subtree);
    t = expect(ctx, 51); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[93],
    rules[55]
  ));
}
function parse_call_input(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[56][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(114, 'call_input'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "call_input";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 57) { // $call_input = :input :colon $_gen14 -> Inputs( map=$2 )
    ctx.rule = rules[57];
    ast_parameters = {
      'map': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Inputs', ast_parameters);
    t = expect(ctx, 31); // :input
    tree.add(t);
    t = expect(ctx, 9); // :colon
    tree.add(t);
    subtree = parse__gen14(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[114],
    rules[57]
  ));
}
function parse_cmd_param(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[34][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(92, 'cmd_param'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "cmd_param";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 23) { // $cmd_param = :cmd_param_start $_gen6 $e :cmd_param_end -> CommandParameter( attributes=$1, expr=$2 )
    ctx.rule = rules[23];
    ast_parameters = {
      'attributes': 1,
      'expr': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('CommandParameter', ast_parameters);
    t = expect(ctx, 54); // :cmd_param_start
    tree.add(t);
    subtree = parse__gen6(ctx);
    tree.add(subtree);
    subtree = parse_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 20); // :cmd_param_end
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[92],
    rules[23]
  ));
}
function parse_cmd_param_kv(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[20][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(78, 'cmd_param_kv'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "cmd_param_kv";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 24) { // $cmd_param_kv = :cmd_attr_hint :identifier :equal $e -> CommandParameterAttr( key=$1, value=$3 )
    ctx.rule = rules[24];
    ast_parameters = {
      'key': 1,
      'value': 3,
    }
    tree.astTransform = new AstTransformNodeCreator('CommandParameterAttr', ast_parameters);
    t = expect(ctx, 7); // :cmd_attr_hint
    tree.add(t);
    t = expect(ctx, 39); // :identifier
    tree.add(t);
    t = expect(ctx, 45); // :equal
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[78],
    rules[24]
  ));
}
function parse_command(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[50][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(108, 'command'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "command";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 19) { // $command = :raw_command :raw_cmd_start $_gen5 :raw_cmd_end -> RawCommand( parts=$2 )
    ctx.rule = rules[19];
    ast_parameters = {
      'parts': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('RawCommand', ast_parameters);
    t = expect(ctx, 49); // :raw_command
    tree.add(t);
    t = expect(ctx, 37); // :raw_cmd_start
    tree.add(t);
    subtree = parse__gen5(ctx);
    tree.add(subtree);
    t = expect(ctx, 2); // :raw_cmd_end
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[108],
    rules[19]
  ));
}
function parse_command_part(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[42][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(100, 'command_part'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "command_part";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 20) { // $command_part = :cmd_part
    ctx.rule = rules[20];
    tree.astTransform = new AstTransformSubstitution(0);
    t = expect(ctx, 1); // :cmd_part
    tree.add(t);
    return tree;
  }
  else if (rule == 21) { // $command_part = $cmd_param
    ctx.rule = rules[21];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_cmd_param(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[100],
    rules[21]
  ));
}
function parse_declaration(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[7][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(65, 'declaration'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "declaration";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 36) { // $declaration = $type_e :identifier $_gen9 -> Declaration( type=$0, name=$1, expression=$2 )
    ctx.rule = rules[36];
    ast_parameters = {
      'type': 0,
      'name': 1,
      'expression': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Declaration', ast_parameters);
    subtree = parse_type_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 39); // :identifier
    tree.add(t);
    subtree = parse__gen9(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[65],
    rules[36]
  ));
}
function parse_document(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[44][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(102, 'document'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "document";
  if (current != null && nonterminal_follow[102].indexOf(current.id) != -1 && nonterminal_first[102].indexOf(current.id) == -1) {
    return tree;
  }
  if (current == null) {
    return tree;
  }
  if (rule == 2) { // $document = $_gen0 $_gen1 -> Namespace( imports=$0, body=$1 )
    ctx.rule = rules[2];
    ast_parameters = {
      'imports': 0,
      'body': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('Namespace', ast_parameters);
    subtree = parse__gen0(ctx);
    tree.add(subtree);
    subtree = parse__gen1(ctx);
    tree.add(subtree);
    return tree;
  }
  return tree;
}
function parse_if_stmt(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[48][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(106, 'if_stmt'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "if_stmt";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 72) { // $if_stmt = :if :lparen $e :rparen :lbrace $_gen10 :rbrace -> If( expression=$2, body=$5 )
    ctx.rule = rules[72];
    ast_parameters = {
      'expression': 2,
      'body': 5,
    }
    tree.astTransform = new AstTransformNodeCreator('If', ast_parameters);
    t = expect(ctx, 46); // :if
    tree.add(t);
    t = expect(ctx, 43); // :lparen
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 5); // :rparen
    tree.add(t);
    t = expect(ctx, 42); // :lbrace
    tree.add(t);
    subtree = parse__gen10(ctx);
    tree.add(subtree);
    t = expect(ctx, 51); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[106],
    rules[72]
  ));
}
function parse_import(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[58][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(116, 'import'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "import";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 8) { // $import = :import :string $_gen2 -> Import( uri=$1, namespace=$2 )
    ctx.rule = rules[8];
    ast_parameters = {
      'uri': 1,
      'namespace': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Import', ast_parameters);
    t = expect(ctx, 36); // :import
    tree.add(t);
    t = expect(ctx, 27); // :string
    tree.add(t);
    subtree = parse__gen2(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[116],
    rules[8]
  ));
}
function parse_import_namespace(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[33][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(91, 'import_namespace'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "import_namespace";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 9) { // $import_namespace = :as :identifier -> $1
    ctx.rule = rules[9];
    tree.astTransform = new AstTransformSubstitution(1);
    t = expect(ctx, 29); // :as
    tree.add(t);
    t = expect(ctx, 39); // :identifier
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[91],
    rules[9]
  ));
}
function parse_kv(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[26][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(84, 'kv'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "kv";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 33) { // $kv = :identifier :colon $e -> RuntimeAttribute( key=$0, value=$2 )
    ctx.rule = rules[33];
    ast_parameters = {
      'key': 0,
      'value': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('RuntimeAttribute', ast_parameters);
    t = expect(ctx, 39); // :identifier
    tree.add(t);
    t = expect(ctx, 9); // :colon
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[84],
    rules[33]
  ));
}
function parse_map(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[45][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(103, 'map'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "map";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 32) { // $map = :lbrace $_gen8 :rbrace -> $1
    ctx.rule = rules[32];
    tree.astTransform = new AstTransformSubstitution(1);
    t = expect(ctx, 42); // :lbrace
    tree.add(t);
    subtree = parse__gen8(ctx);
    tree.add(subtree);
    t = expect(ctx, 51); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[103],
    rules[32]
  ));
}
function parse_map_kv(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[15][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(73, 'map_kv'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "map_kv";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 38) { // $map_kv = $e :colon $e -> MapLiteralKv( key=$0, value=$2 )
    ctx.rule = rules[38];
    ast_parameters = {
      'key': 0,
      'value': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('MapLiteralKv', ast_parameters);
    subtree = parse_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 9); // :colon
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[73],
    rules[38]
  ));
}
function parse_mapping(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[3][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(61, 'mapping'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "mapping";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 58) { // $mapping = :identifier :equal $e -> IOMapping( key=$0, value=$2 )
    ctx.rule = rules[58];
    ast_parameters = {
      'key': 0,
      'value': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('IOMapping', ast_parameters);
    t = expect(ctx, 39); // :identifier
    tree.add(t);
    t = expect(ctx, 45); // :equal
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[61],
    rules[58]
  ));
}
function parse_meta(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[22][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(80, 'meta'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "meta";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 30) { // $meta = :meta $map -> Meta( map=$1 )
    ctx.rule = rules[30];
    ast_parameters = {
      'map': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('Meta', ast_parameters);
    t = expect(ctx, 33); // :meta
    tree.add(t);
    subtree = parse_map(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[80],
    rules[30]
  ));
}
function parse_object_kv(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[31][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(89, 'object_kv'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "object_kv";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 74) { // $object_kv = :identifier :colon $e -> ObjectKV( key=$0, value=$2 )
    ctx.rule = rules[74];
    ast_parameters = {
      'key': 0,
      'value': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('ObjectKV', ast_parameters);
    t = expect(ctx, 39); // :identifier
    tree.add(t);
    t = expect(ctx, 9); // :colon
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[89],
    rules[74]
  ));
}
function parse_output_kv(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[10][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(68, 'output_kv'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "output_kv";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 27) { // $output_kv = $type_e :identifier :equal $e -> Output( type=$0, name=$1, expression=$3 )
    ctx.rule = rules[27];
    ast_parameters = {
      'type': 0,
      'name': 1,
      'expression': 3,
    }
    tree.astTransform = new AstTransformNodeCreator('Output', ast_parameters);
    subtree = parse_type_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 39); // :identifier
    tree.add(t);
    t = expect(ctx, 45); // :equal
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[68],
    rules[27]
  ));
}
function parse_outputs(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[54][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(112, 'outputs'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "outputs";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 26) { // $outputs = :output :lbrace $_gen7 :rbrace -> Outputs( attributes=$2 )
    ctx.rule = rules[26];
    ast_parameters = {
      'attributes': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('Outputs', ast_parameters);
    t = expect(ctx, 23); // :output
    tree.add(t);
    t = expect(ctx, 42); // :lbrace
    tree.add(t);
    subtree = parse__gen7(ctx);
    tree.add(subtree);
    t = expect(ctx, 51); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[112],
    rules[26]
  ));
}
function parse_parameter_meta(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[47][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(105, 'parameter_meta'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "parameter_meta";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 29) { // $parameter_meta = :parameter_meta $map -> ParameterMeta( map=$1 )
    ctx.rule = rules[29];
    ast_parameters = {
      'map': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('ParameterMeta', ast_parameters);
    t = expect(ctx, 44); // :parameter_meta
    tree.add(t);
    subtree = parse_map(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[105],
    rules[29]
  ));
}
function parse_runtime(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[0][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(58, 'runtime'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "runtime";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 28) { // $runtime = :runtime $map -> Runtime( map=$1 )
    ctx.rule = rules[28];
    ast_parameters = {
      'map': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('Runtime', ast_parameters);
    t = expect(ctx, 16); // :runtime
    tree.add(t);
    subtree = parse_map(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[58],
    rules[28]
  ));
}
function parse_scatter(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[40][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(98, 'scatter'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "scatter";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 73) { // $scatter = :scatter :lparen :identifier :in $e :rparen :lbrace $_gen10 :rbrace -> Scatter( item=$2, collection=$4, body=$7 )
    ctx.rule = rules[73];
    ast_parameters = {
      'item': 2,
      'collection': 4,
      'body': 7,
    }
    tree.astTransform = new AstTransformNodeCreator('Scatter', ast_parameters);
    t = expect(ctx, 25); // :scatter
    tree.add(t);
    t = expect(ctx, 43); // :lparen
    tree.add(t);
    t = expect(ctx, 39); // :identifier
    tree.add(t);
    t = expect(ctx, 24); // :in
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 5); // :rparen
    tree.add(t);
    t = expect(ctx, 42); // :lbrace
    tree.add(t);
    subtree = parse__gen10(ctx);
    tree.add(subtree);
    t = expect(ctx, 51); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[98],
    rules[73]
  ));
}
function parse_sections(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[53][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(111, 'sections'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "sections";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 13) { // $sections = $command
    ctx.rule = rules[13];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_command(ctx);
    tree.add(subtree);
    return tree;
  }
  else if (rule == 14) { // $sections = $outputs
    ctx.rule = rules[14];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_outputs(ctx);
    tree.add(subtree);
    return tree;
  }
  else if (rule == 15) { // $sections = $runtime
    ctx.rule = rules[15];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_runtime(ctx);
    tree.add(subtree);
    return tree;
  }
  else if (rule == 16) { // $sections = $parameter_meta
    ctx.rule = rules[16];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_parameter_meta(ctx);
    tree.add(subtree);
    return tree;
  }
  else if (rule == 17) { // $sections = $meta
    ctx.rule = rules[17];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_meta(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[111],
    rules[17]
  ));
}
function parse_setter(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[8][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(66, 'setter'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "setter";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 37) { // $setter = :equal $e -> $1
    ctx.rule = rules[37];
    tree.astTransform = new AstTransformSubstitution(1);
    t = expect(ctx, 45); // :equal
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[66],
    rules[37]
  ));
}
function parse_task(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[39][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(97, 'task'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "task";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 12) { // $task = :task :identifier :lbrace $_gen3 $_gen4 :rbrace -> Task( name=$1, declarations=$3, sections=$4 )
    ctx.rule = rules[12];
    ast_parameters = {
      'name': 1,
      'declarations': 3,
      'sections': 4,
    }
    tree.astTransform = new AstTransformNodeCreator('Task', ast_parameters);
    t = expect(ctx, 4); // :task
    tree.add(t);
    t = expect(ctx, 39); // :identifier
    tree.add(t);
    t = expect(ctx, 42); // :lbrace
    tree.add(t);
    subtree = parse__gen3(ctx);
    tree.add(subtree);
    subtree = parse__gen4(ctx);
    tree.add(subtree);
    t = expect(ctx, 51); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[97],
    rules[12]
  ));
}
function parse_wf_body_element(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[60][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(118, 'wf_body_element'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "wf_body_element";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 41) { // $wf_body_element = $call
    ctx.rule = rules[41];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_call(ctx);
    tree.add(subtree);
    return tree;
  }
  else if (rule == 42) { // $wf_body_element = $declaration
    ctx.rule = rules[42];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_declaration(ctx);
    tree.add(subtree);
    return tree;
  }
  else if (rule == 43) { // $wf_body_element = $while_loop
    ctx.rule = rules[43];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_while_loop(ctx);
    tree.add(subtree);
    return tree;
  }
  else if (rule == 44) { // $wf_body_element = $if_stmt
    ctx.rule = rules[44];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_if_stmt(ctx);
    tree.add(subtree);
    return tree;
  }
  else if (rule == 45) { // $wf_body_element = $scatter
    ctx.rule = rules[45];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_scatter(ctx);
    tree.add(subtree);
    return tree;
  }
  else if (rule == 46) { // $wf_body_element = $wf_outputs
    ctx.rule = rules[46];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_wf_outputs(ctx);
    tree.add(subtree);
    return tree;
  }
  else if (rule == 47) { // $wf_body_element = $wf_parameter_meta
    ctx.rule = rules[47];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_wf_parameter_meta(ctx);
    tree.add(subtree);
    return tree;
  }
  else if (rule == 48) { // $wf_body_element = $wf_meta
    ctx.rule = rules[48];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_wf_meta(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[118],
    rules[48]
  ));
}
function parse_wf_meta(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[12][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(70, 'wf_meta'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "wf_meta";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 70) { // $wf_meta = :meta $map -> Meta( map=$1 )
    ctx.rule = rules[70];
    ast_parameters = {
      'map': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('Meta', ast_parameters);
    t = expect(ctx, 33); // :meta
    tree.add(t);
    subtree = parse_map(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[70],
    rules[70]
  ));
}
function parse_wf_output(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[5][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(63, 'wf_output'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "wf_output";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 62) { // $wf_output = $wf_output_declaration_syntax
    ctx.rule = rules[62];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_wf_output_declaration_syntax(ctx);
    tree.add(subtree);
    return tree;
  }
  else if (rule == 63) { // $wf_output = $wf_output_wildcard_syntax
    ctx.rule = rules[63];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_wf_output_wildcard_syntax(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[63],
    rules[63]
  ));
}
function parse_wf_output_declaration_syntax(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[6][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(64, 'wf_output_declaration_syntax'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "wf_output_declaration_syntax";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 64) { // $wf_output_declaration_syntax = $type_e :identifier :equal $e -> WorkflowOutputDeclaration( type=$0, name=$1, expression=$3 )
    ctx.rule = rules[64];
    ast_parameters = {
      'type': 0,
      'name': 1,
      'expression': 3,
    }
    tree.astTransform = new AstTransformNodeCreator('WorkflowOutputDeclaration', ast_parameters);
    subtree = parse_type_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 39); // :identifier
    tree.add(t);
    t = expect(ctx, 45); // :equal
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[64],
    rules[64]
  ));
}
function parse_wf_output_wildcard(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[13][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(71, 'wf_output_wildcard'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "wf_output_wildcard";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 68) { // $wf_output_wildcard = :dot :asterisk -> $1
    ctx.rule = rules[68];
    tree.astTransform = new AstTransformSubstitution(1);
    t = expect(ctx, 35); // :dot
    tree.add(t);
    t = expect(ctx, 10); // :asterisk
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[71],
    rules[68]
  ));
}
function parse_wf_output_wildcard_syntax(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[11][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(69, 'wf_output_wildcard_syntax'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "wf_output_wildcard_syntax";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 67) { // $wf_output_wildcard_syntax = :fqn $_gen16 -> WorkflowOutputWildcard( fqn=$0, wildcard=$1 )
    ctx.rule = rules[67];
    ast_parameters = {
      'fqn': 0,
      'wildcard': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('WorkflowOutputWildcard', ast_parameters);
    t = expect(ctx, 40); // :fqn
    tree.add(t);
    subtree = parse__gen16(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[69],
    rules[67]
  ));
}
function parse_wf_outputs(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[27][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(85, 'wf_outputs'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "wf_outputs";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 61) { // $wf_outputs = :output :lbrace $_gen15 :rbrace -> WorkflowOutputs( outputs=$2 )
    ctx.rule = rules[61];
    ast_parameters = {
      'outputs': 2,
    }
    tree.astTransform = new AstTransformNodeCreator('WorkflowOutputs', ast_parameters);
    t = expect(ctx, 23); // :output
    tree.add(t);
    t = expect(ctx, 42); // :lbrace
    tree.add(t);
    subtree = parse__gen15(ctx);
    tree.add(subtree);
    t = expect(ctx, 51); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[85],
    rules[61]
  ));
}
function parse_wf_parameter_meta(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[41][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(99, 'wf_parameter_meta'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "wf_parameter_meta";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 69) { // $wf_parameter_meta = :parameter_meta $map -> ParameterMeta( map=$1 )
    ctx.rule = rules[69];
    ast_parameters = {
      'map': 1,
    }
    tree.astTransform = new AstTransformNodeCreator('ParameterMeta', ast_parameters);
    t = expect(ctx, 44); // :parameter_meta
    tree.add(t);
    subtree = parse_map(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[99],
    rules[69]
  ));
}
function parse_while_loop(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[4][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(62, 'while_loop'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "while_loop";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 71) { // $while_loop = :while :lparen $e :rparen :lbrace $_gen10 :rbrace -> WhileLoop( expression=$2, body=$5 )
    ctx.rule = rules[71];
    ast_parameters = {
      'expression': 2,
      'body': 5,
    }
    tree.astTransform = new AstTransformNodeCreator('WhileLoop', ast_parameters);
    t = expect(ctx, 6); // :while
    tree.add(t);
    t = expect(ctx, 43); // :lparen
    tree.add(t);
    subtree = parse_e(ctx);
    tree.add(subtree);
    t = expect(ctx, 5); // :rparen
    tree.add(t);
    t = expect(ctx, 42); // :lbrace
    tree.add(t);
    subtree = parse__gen10(ctx);
    tree.add(subtree);
    t = expect(ctx, 51); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[62],
    rules[71]
  ));
}
function parse_workflow(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[9][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(67, 'workflow'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "workflow";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 40) { // $workflow = :workflow :identifier :lbrace $_gen10 :rbrace -> Workflow( name=$1, body=$3 )
    ctx.rule = rules[40];
    ast_parameters = {
      'name': 1,
      'body': 3,
    }
    tree.astTransform = new AstTransformNodeCreator('Workflow', ast_parameters);
    t = expect(ctx, 50); // :workflow
    tree.add(t);
    t = expect(ctx, 39); // :identifier
    tree.add(t);
    t = expect(ctx, 42); // :lbrace
    tree.add(t);
    subtree = parse__gen10(ctx);
    tree.add(subtree);
    t = expect(ctx, 51); // :rbrace
    tree.add(t);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[67],
    rules[40]
  ));
}
function parse_workflow_or_task_or_decl(ctx) {
  var current = ctx.tokens.current();
  var rule = current != null ? table[29][current.id] : -1;
  var tree = new ParseTree(new NonTerminal(87, 'workflow_or_task_or_decl'));
  var ast_parameters;
  var subtree;
  var t;
  ctx.nonterminal = "workflow_or_task_or_decl";
  if (current == null) {
    throw new SyntaxError('Error: unexpected end of file');
  }
  if (rule == 3) { // $workflow_or_task_or_decl = $workflow
    ctx.rule = rules[3];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_workflow(ctx);
    tree.add(subtree);
    return tree;
  }
  else if (rule == 4) { // $workflow_or_task_or_decl = $task
    ctx.rule = rules[4];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_task(ctx);
    tree.add(subtree);
    return tree;
  }
  else if (rule == 5) { // $workflow_or_task_or_decl = $declaration
    ctx.rule = rules[5];
    tree.astTransform = new AstTransformSubstitution(0);
    subtree = parse_declaration(ctx);
    tree.add(subtree);
    return tree;
  }
  throw new SyntaxError(ctx.error_formatter.unexpected_symbol(
    ctx.nonterminal,
    ctx.tokens.current(),
    nonterminal_first[87],
    rules[5]
  ));
}
// Section: Lexer
// START USER CODE
function init() {
  return {wf_or_task: null};
}
function workflow(ctx, terminal, source_string, line, col) {
  ctx.user_context.wf_or_task = "workflow";
  default_action(ctx, terminal, source_string, line, col);
}
function task(ctx, terminal, source_string, line, col) {
  ctx.user_context.wf_or_task = "task";
  default_action(ctx, terminal, source_string, line, col);
}
function output(ctx, terminal, source_string, line, col) {
  const user_ctx = ctx.user_context;
  if (user_ctx.wf_or_task != null && user_ctx.wf_or_task === "workflow") {
    ctx.mode_stack.push("wf_output");
  }
  default_action(ctx, terminal, source_string, line, col);
}
function wdl_unescape(ctx, terminal, source_string, line, col) {
  var strip_slashes = function(str) {
    return str
      .replace(/\\(.?)/g, function (s, n1) {
        var escapes = {
          '\\': '\\',
          '0' : '\u0000',
          ''  : '',
          'n' : '\n',
          'r' : '\r',
          'b' : '\b',
          't' : '\t',
          'f' : '\f',
          'a' : '\a',
          'v' : '\v'};
        var symbol = escapes[n1];
        if (symbol !== undefined) {
          return symbol;
        }
        return n1;
      });
  }
  var repl_str = strip_slashes(source_string.substring(1, source_string.length - 1));
  default_action(ctx, terminal, repl_str, line, col);
}
// END USER CODE
function emit(ctx, terminal, source_string, line, col) {
  ctx.tokens.push(new Terminal(terminals[terminal], terminal, source_string, ctx.resource, line, col))
}
function default_action(ctx, terminal, source_string, line, col) {
  emit(ctx, terminal, source_string, line, col)
}
function post_filter(tokens) {
  return tokens
}
function destroy(context) {
  return 0;
}
var regex = {
  'default': [
    {
      regex: new RegExp("\\s+"),
      outputs: [
      ]
    },
    {
      regex: new RegExp("/\\*(.*?)\\*/", "m"),
      outputs: [
      ]
    },
    {
      regex: new RegExp("#.*"),
      outputs: [
      ]
    },
    {
      regex: new RegExp("task(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'task',
          group: 0,
          function: task,
        },
      ]
    },
    {
      regex: new RegExp("(call)\\s+"),
      outputs: [
        {
          terminal: 'call',
          group: 1,
          function: null,
        },
        {
          stack_push: 'task_fqn',
        },
      ]
    },
    {
      regex: new RegExp("workflow(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'workflow',
          group: 0,
          function: workflow,
        },
      ]
    },
    {
      regex: new RegExp("import(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'import',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("input(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'input',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("output(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'output',
          group: 0,
          function: output,
        },
      ]
    },
    {
      regex: new RegExp("as(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'as',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("if(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'if',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("then(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'then',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("else(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'else',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("while(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'while',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("runtime(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'runtime',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("scatter(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'scatter',
          group: 0,
          function: null,
        },
        {
          stack_push: 'scatter',
        },
      ]
    },
    {
      regex: new RegExp("command\\s*(?=<<<)"),
      outputs: [
        {
          terminal: 'raw_command',
          group: 0,
          function: null,
        },
        {
          stack_push: 'raw_command2',
        },
      ]
    },
    {
      regex: new RegExp("command\\s*(?=\\{)"),
      outputs: [
        {
          terminal: 'raw_command',
          group: 0,
          function: null,
        },
        {
          stack_push: 'raw_command',
        },
      ]
    },
    {
      regex: new RegExp("parameter_meta(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'parameter_meta',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("meta(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'meta',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("(true|false)(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'boolean',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("(object)\\s*(\\{)"),
      outputs: [
        {
          terminal: 'object',
          group: 0,
          function: null,
        },
        {
          terminal: 'lbrace',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("(Array|Map|Object|Pair|Boolean|Int|Float|Uri|File|String)(?![a-zA-Z0-9_])(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'type',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*"),
      outputs: [
        {
          terminal: 'identifier',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\\"([^\\\\\\\"\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*\\\\?\""),
      outputs: [
        {
          terminal: 'string',
          group: 0,
          function: wdl_unescape,
        },
      ]
    },
    {
      regex: new RegExp("'([^\\\\\\'\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*'"),
      outputs: [
        {
          terminal: 'string',
          group: 0,
          function: wdl_unescape,
        },
      ]
    },
    {
      regex: new RegExp(":"),
      outputs: [
        {
          terminal: 'colon',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(","),
      outputs: [
        {
          terminal: 'comma',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("=="),
      outputs: [
        {
          terminal: 'double_equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\|\\|"),
      outputs: [
        {
          terminal: 'double_pipe',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\&\\&"),
      outputs: [
        {
          terminal: 'double_ampersand',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("!="),
      outputs: [
        {
          terminal: 'not_equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("="),
      outputs: [
        {
          terminal: 'equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\."),
      outputs: [
        {
          terminal: 'dot',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\{"),
      outputs: [
        {
          terminal: 'lbrace',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\}"),
      outputs: [
        {
          terminal: 'rbrace',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\("),
      outputs: [
        {
          terminal: 'lparen',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\)"),
      outputs: [
        {
          terminal: 'rparen',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\["),
      outputs: [
        {
          terminal: 'lsquare',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\]"),
      outputs: [
        {
          terminal: 'rsquare',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\+"),
      outputs: [
        {
          terminal: 'plus',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\*"),
      outputs: [
        {
          terminal: 'asterisk',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("-"),
      outputs: [
        {
          terminal: 'dash',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("/"),
      outputs: [
        {
          terminal: 'slash',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("%"),
      outputs: [
        {
          terminal: 'percent',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("<="),
      outputs: [
        {
          terminal: 'lteq',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("<"),
      outputs: [
        {
          terminal: 'lt',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(">="),
      outputs: [
        {
          terminal: 'gteq',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(">"),
      outputs: [
        {
          terminal: 'gt',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("!"),
      outputs: [
        {
          terminal: 'not',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\?"),
      outputs: [
        {
          terminal: 'qmark',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("-?[0-9]+\\.[0-9]+"),
      outputs: [
        {
          terminal: 'float',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("[0-9]+"),
      outputs: [
        {
          terminal: 'integer',
          group: 0,
          function: null,
        },
      ]
    },
  ],
  'wf_output': [
    {
      regex: new RegExp("\\s+"),
      outputs: [
      ]
    },
    {
      regex: new RegExp("#.*"),
      outputs: [
      ]
    },
    {
      regex: new RegExp("(Array|Map|Object|Pair|Boolean|Int|Float|Uri|File|String)(?![a-zA-Z0-9_])(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'type',
          group: 0,
          function: null,
        },
        {
          action: 'pop',
        },
        {
          stack_push: 'wf_output_declaration',
        },
      ]
    },
    {
      regex: new RegExp("\\{"),
      outputs: [
        {
          terminal: 'lbrace',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\}"),
      outputs: [
        {
          terminal: 'rbrace',
          group: 0,
          function: null,
        },
        {
          action: 'pop',
        },
      ]
    },
    {
      regex: new RegExp(","),
      outputs: [
        {
          terminal: 'comma',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\."),
      outputs: [
        {
          terminal: 'dot',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\*"),
      outputs: [
        {
          terminal: 'asterisk',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*(\\.[a-zA-Z]([a-zA-Z0-9_])*)*"),
      outputs: [
        {
          terminal: 'fqn',
          group: 0,
          function: null,
        },
      ]
    },
  ],
  'wf_output_declaration': [
    {
      regex: new RegExp("\\s+"),
      outputs: [
      ]
    },
    {
      regex: new RegExp("#.*"),
      outputs: [
      ]
    },
    {
      regex: new RegExp("\\}"),
      outputs: [
        {
          terminal: 'rbrace',
          group: 0,
          function: null,
        },
        {
          action: 'pop',
        },
      ]
    },
    {
      regex: new RegExp("\\["),
      outputs: [
        {
          terminal: 'lsquare',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\]"),
      outputs: [
        {
          terminal: 'rsquare',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\+"),
      outputs: [
        {
          terminal: 'plus',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\*"),
      outputs: [
        {
          terminal: 'asterisk',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("[0-9]+"),
      outputs: [
        {
          terminal: 'integer',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("(true|false)(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'boolean',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("if"),
      outputs: [
        {
          terminal: 'if',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("else"),
      outputs: [
        {
          terminal: 'else',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("then"),
      outputs: [
        {
          terminal: 'then',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("(Array|Map|Object|Pair|Boolean|Int|Float|Uri|File|String)(?![a-zA-Z0-9_])(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'type',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*"),
      outputs: [
        {
          terminal: 'identifier',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(":"),
      outputs: [
        {
          terminal: 'colon',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(","),
      outputs: [
        {
          terminal: 'comma',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\."),
      outputs: [
        {
          terminal: 'dot',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("=="),
      outputs: [
        {
          terminal: 'double_equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("="),
      outputs: [
        {
          terminal: 'equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\|\\|"),
      outputs: [
        {
          terminal: 'double_pipe',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\&\\&"),
      outputs: [
        {
          terminal: 'double_ampersand',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("!="),
      outputs: [
        {
          terminal: 'not_equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("="),
      outputs: [
        {
          terminal: 'equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\."),
      outputs: [
        {
          terminal: 'dot',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\{"),
      outputs: [
        {
          terminal: 'lbrace',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\("),
      outputs: [
        {
          terminal: 'lparen',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\)"),
      outputs: [
        {
          terminal: 'rparen',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\["),
      outputs: [
        {
          terminal: 'lsquare',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\]"),
      outputs: [
        {
          terminal: 'rsquare',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\+"),
      outputs: [
        {
          terminal: 'plus',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\*"),
      outputs: [
        {
          terminal: 'asterisk',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("-"),
      outputs: [
        {
          terminal: 'dash',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("/"),
      outputs: [
        {
          terminal: 'slash',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("%"),
      outputs: [
        {
          terminal: 'percent',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("<="),
      outputs: [
        {
          terminal: 'lteq',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("<"),
      outputs: [
        {
          terminal: 'lt',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(">="),
      outputs: [
        {
          terminal: 'gteq',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(">"),
      outputs: [
        {
          terminal: 'gt',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("!"),
      outputs: [
        {
          terminal: 'not',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\?"),
      outputs: [
        {
          terminal: 'qmark',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\\"([^\\\\\\\"\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*\\\\?\""),
      outputs: [
        {
          terminal: 'string',
          group: 0,
          function: wdl_unescape,
        },
      ]
    },
    {
      regex: new RegExp("'([^\\\\\\'\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*'"),
      outputs: [
        {
          terminal: 'string',
          group: 0,
          function: wdl_unescape,
        },
      ]
    },
    {
      regex: new RegExp("-?[0-9]+\\.[0-9]+"),
      outputs: [
        {
          terminal: 'float',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("[0-9]+"),
      outputs: [
        {
          terminal: 'integer',
          group: 0,
          function: null,
        },
      ]
    },
  ],
  'task_fqn': [
    {
      regex: new RegExp("\\s+"),
      outputs: [
      ]
    },
    {
      regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*(\\.[a-zA-Z]([a-zA-Z0-9_])*)*"),
      outputs: [
        {
          terminal: 'fqn',
          group: 0,
          function: null,
        },
        {
          action: 'pop',
        },
      ]
    },
  ],
  'scatter': [
    {
      regex: new RegExp("\\s+"),
      outputs: [
      ]
    },
    {
      regex: new RegExp("\\("),
      outputs: [
        {
          terminal: 'lparen',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("in(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'in',
          group: 0,
          function: null,
        },
        {
          action: 'pop',
        },
      ]
    },
    {
      regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*"),
      outputs: [
        {
          terminal: 'identifier',
          group: 0,
          function: null,
        },
      ]
    },
  ],
  'raw_command': [
    {
      regex: new RegExp("\\{"),
      outputs: [
        {
          terminal: 'raw_cmd_start',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\}"),
      outputs: [
        {
          terminal: 'raw_cmd_end',
          group: 0,
          function: null,
        },
        {
          action: 'pop',
        },
      ]
    },
    {
      regex: new RegExp("\\$\\{"),
      outputs: [
        {
          terminal: 'cmd_param_start',
          group: 0,
          function: null,
        },
        {
          stack_push: 'cmd_param',
        },
      ]
    },
    {
      regex: new RegExp("([\\s\\S]*?)(?=\\$\\{|\\})", "m"),
      outputs: [
        {
          terminal: 'cmd_part',
          group: 0,
          function: null,
        },
      ]
    },
  ],
  'raw_command2': [
    {
      regex: new RegExp("<<<"),
      outputs: [
        {
          terminal: 'raw_cmd_start',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(">>>"),
      outputs: [
        {
          terminal: 'raw_cmd_end',
          group: 0,
          function: null,
        },
        {
          action: 'pop',
        },
      ]
    },
    {
      regex: new RegExp("\\$\\{"),
      outputs: [
        {
          terminal: 'cmd_param_start',
          group: 0,
          function: null,
        },
        {
          stack_push: 'cmd_param',
        },
      ]
    },
    {
      regex: new RegExp("([\\s\\S]*?)(?=\\$\\{|>>>)", "m"),
      outputs: [
        {
          terminal: 'cmd_part',
          group: 0,
          function: null,
        },
      ]
    },
  ],
  'cmd_param': [
    {
      regex: new RegExp("\\s+"),
      outputs: [
      ]
    },
    {
      regex: new RegExp("\\}"),
      outputs: [
        {
          terminal: 'cmd_param_end',
          group: 0,
          function: null,
        },
        {
          action: 'pop',
        },
      ]
    },
    {
      regex: new RegExp("\\["),
      outputs: [
        {
          terminal: 'lsquare',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\]"),
      outputs: [
        {
          terminal: 'rsquare',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("="),
      outputs: [
        {
          terminal: 'equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\+"),
      outputs: [
        {
          terminal: 'plus',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\*"),
      outputs: [
        {
          terminal: 'asterisk',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("[0-9]+"),
      outputs: [
        {
          terminal: 'integer',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("if"),
      outputs: [
        {
          terminal: 'if',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("else"),
      outputs: [
        {
          terminal: 'else',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("then"),
      outputs: [
        {
          terminal: 'then',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*(?=\\s*=)"),
      outputs: [
        {
          terminal: 'cmd_attr_hint',
          group: null,
          function: null,
        },
        {
          terminal: 'identifier',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("(true|false)(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'boolean',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("(Array|Map|Object|Pair|Boolean|Int|Float|Uri|File|String)(?![a-zA-Z0-9_])(?![a-zA-Z0-9_])"),
      outputs: [
        {
          terminal: 'type',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("[a-zA-Z]([a-zA-Z0-9_])*"),
      outputs: [
        {
          terminal: 'identifier',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(":"),
      outputs: [
        {
          terminal: 'colon',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(","),
      outputs: [
        {
          terminal: 'comma',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\."),
      outputs: [
        {
          terminal: 'dot',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("=="),
      outputs: [
        {
          terminal: 'double_equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\|\\|"),
      outputs: [
        {
          terminal: 'double_pipe',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\&\\&"),
      outputs: [
        {
          terminal: 'double_ampersand',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("!="),
      outputs: [
        {
          terminal: 'not_equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("="),
      outputs: [
        {
          terminal: 'equal',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\."),
      outputs: [
        {
          terminal: 'dot',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\{"),
      outputs: [
        {
          terminal: 'lbrace',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\("),
      outputs: [
        {
          terminal: 'lparen',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\)"),
      outputs: [
        {
          terminal: 'rparen',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\["),
      outputs: [
        {
          terminal: 'lsquare',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\]"),
      outputs: [
        {
          terminal: 'rsquare',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\+"),
      outputs: [
        {
          terminal: 'plus',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\*"),
      outputs: [
        {
          terminal: 'asterisk',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("-"),
      outputs: [
        {
          terminal: 'dash',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("/"),
      outputs: [
        {
          terminal: 'slash',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("%"),
      outputs: [
        {
          terminal: 'percent',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("<="),
      outputs: [
        {
          terminal: 'lteq',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("<"),
      outputs: [
        {
          terminal: 'lt',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(">="),
      outputs: [
        {
          terminal: 'gteq',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp(">"),
      outputs: [
        {
          terminal: 'gt',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("!"),
      outputs: [
        {
          terminal: 'not',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("\\\"([^\\\\\\\"\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*\\\\?\""),
      outputs: [
        {
          terminal: 'string',
          group: 0,
          function: wdl_unescape,
        },
      ]
    },
    {
      regex: new RegExp("'([^\\\\\\'\\n]|\\\\[\\\"\\'nrbtfav\\\\?]|\\\\[0-7]{1,3}|\\\\x[0-9a-fA-F]+|\\\\[uU]([0-9a-fA-F]{4})([0-9a-fA-F]{4})?)*'"),
      outputs: [
        {
          terminal: 'string',
          group: 0,
          function: wdl_unescape,
        },
      ]
    },
    {
      regex: new RegExp("-?[0-9]+\\.[0-9]+"),
      outputs: [
        {
          terminal: 'float',
          group: 0,
          function: null,
        },
      ]
    },
    {
      regex: new RegExp("[0-9]+"),
      outputs: [
        {
          terminal: 'integer',
          group: 0,
          function: null,
        },
      ]
    },
  ],
}
function advance_line_col(string, length, line, col) {
  for (var i = 0; i < length; i++) {
    if (string[i] == '\n') {
      line += 1;
      col = 1;
    } else {
      col += 1;
    }
  }
  return {line: line, col: col}
}
function advance_string(ctx, string) {
  var lc = advance_line_col(string, string.length, ctx.line, ctx.col)
  ctx.line = lc.line
  ctx.col = lc.col
  ctx.string = ctx.string.substring(string.length)
}
function _unrecognized_token(string, line, col) {
  var lines = string.split('\n')
  var bad_line = lines[line-1]
  var message = 'Unrecognized token on line {0}, column {1}:\n\n{2}\n{3}'.format(
    line, col, bad_line, Array(col).join(' ') + '^'
  )
  throw new SyntaxError(message)
}
function _next(ctx) {
  var tokens = []
  var mode = ctx.mode_stack[ctx.mode_stack.length - 1]
  for (var i = 0; i < regex[mode].length; i++) {
    var match = regex[mode][i].regex.exec(ctx.string);
    if (match != null && match.index == 0) {
      for (var j = 0; j < regex[mode][i].outputs.length; j++) {
        var terminal = regex[mode][i].outputs[j].terminal;
        var group = regex[mode][i].outputs[j].group;
        var func = regex[mode][i].outputs[j].function;
        var stack_push = regex[mode][i].outputs[j].stack_push;
        var action = regex[mode][i].outputs[j].action;
        if (stack_push !== undefined) {
          ctx.mode_stack.push(stack_push)
        } else if (action !== undefined) {
          if (action == 'pop') {
            ctx.mode_stack.pop()
          }
        } else {
          func = (func == null) ? default_action : func;
          var source_string = group != null ? match[group] : ""
          // Ugh!  JavaScript why you no have regex group indexes?!
          var group_line = ctx.line
          var group_col = ctx.col
          try {
            var mult_regex = new MultiRegExp(regex[mode][i].regex.source);
            var mult_groups = mult_regex.exec(ctx.string)
            if (group != null && group > 0) {
              var lc = advance_line_col(match[0], mult_groups[group-1].index, ctx.line, ctx.col)
              group_line = lc.line
              group_col = lc.col
            }
          } catch(err) {}
          // ^ Literally the worst thing ever
          func(ctx, terminal, source_string, group_line, group_col)
        }
      }
      advance_string(ctx, match[0])
      return true
    }
  }
  return false
}
function lex(string, resource) {
  var ctx = {
    string: string,
    resource: resource,
    user_context: init(),
    mode_stack: ['default'],
    tokens: [],
    line: 1,
    col: 1
  }
  var string_copy = string
  var parsed_tokens = []
  while (ctx.string.length) {
    var matched = _next(ctx)
    if (matched == false) {
      _unrecognized_token(string_copy, ctx.line, ctx.col)
    }
  }
  destroy(ctx.user_context)
  var filtered = post_filter(ctx.tokens)
  return new TokenStream(filtered)
}
// Section: Main
// Section: Exports
module.exports = {
  lex: lex,
  parse: parse,
  terminals: terminals,
  parse_tree_string: parse_tree_string,
  ast_string: ast_string
}
